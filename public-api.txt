sys:
    sys/wasi/net.rs:    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
    sys/wasi/net.rs:    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {
    sys/wasi/net.rs:    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/wasi/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/wasi/net.rs:    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/wasi/net.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/wasi/net.rs:    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/wasi/net.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/wasi/net.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/wasi/net.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/wasi/net.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/wasi/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/wasi/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/wasi/net.rs:    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn duplicate(&self) -> io::Result<TcpStream> {
    sys/wasi/net.rs:    pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/wasi/net.rs:    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn nodelay(&self) -> io::Result<bool> {
    sys/wasi/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/wasi/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/wasi/net.rs:    pub fn set_nonblocking(&self, state: bool) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn socket(&self) -> &Socket {
    sys/wasi/net.rs:    pub fn into_socket(self) -> Socket {
    sys/wasi/net.rs:    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
    sys/wasi/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/wasi/net.rs:    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {
    sys/wasi/net.rs:    pub fn duplicate(&self) -> io::Result<TcpListener> {
    sys/wasi/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/wasi/net.rs:    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn only_v6(&self) -> io::Result<bool> {
    sys/wasi/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/wasi/net.rs:    pub fn set_nonblocking(&self, state: bool) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn socket(&self) -> &Socket {
    sys/wasi/net.rs:    pub fn into_socket(self) -> Socket {
    sys/wasi/net.rs:    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {
    sys/wasi/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/wasi/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/wasi/net.rs:    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/wasi/net.rs:    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/wasi/net.rs:    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {
    sys/wasi/net.rs:    pub fn duplicate(&self) -> io::Result<UdpSocket> {
    sys/wasi/net.rs:    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/wasi/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/wasi/net.rs:    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn broadcast(&self) -> io::Result<bool> {
    sys/wasi/net.rs:    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn multicast_loop_v4(&self) -> io::Result<bool> {
    sys/wasi/net.rs:    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {
    sys/wasi/net.rs:    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn multicast_loop_v6(&self) -> io::Result<bool> {
    sys/wasi/net.rs:    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/wasi/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/wasi/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/wasi/net.rs:    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/wasi/net.rs:    pub fn send(&self, _: &[u8]) -> io::Result<usize> {
    sys/wasi/net.rs:    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {
    sys/wasi/net.rs:    pub fn socket(&self) -> &Socket {
    sys/wasi/net.rs:    pub fn into_socket(self) -> Socket {
    sys/wasi/net.rs:    pub fn port(&self) -> u16 {
    sys/wasi/mod.rs:pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {
    sys/wasi/mod.rs:pub fn abort_internal() -> ! {
    sys/wasi/mod.rs:pub fn hashmap_random_keys() -> (u64, u64) {
    sys/wasi/os.rs:        pub fn getcwd(buf: *mut c_char, size: size_t) -> *mut c_char;
    sys/wasi/os.rs:        pub fn chdir(dir: *const c_char) -> c_int;
    sys/wasi/os.rs:        pub fn __wasilibc_get_environ() -> *mut *mut c_char;
    sys/wasi/os.rs:        pub fn env_read_lock() -> impl Drop {
    sys/wasi/os.rs:        pub fn env_write_lock() -> impl Drop {
    sys/wasi/os.rs:        pub fn env_read_lock() -> impl Drop {
    sys/wasi/os.rs:        pub fn env_write_lock() -> impl Drop {
    sys/wasi/os.rs:pub fn errno() -> i32 {
    sys/wasi/os.rs:pub fn error_string(errno: i32) -> String {
    sys/wasi/os.rs:pub fn getcwd() -> io::Result<PathBuf> {
    sys/wasi/os.rs:pub fn chdir(p: &path::Path) -> io::Result<()> {
    sys/wasi/os.rs:pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {
    sys/wasi/os.rs:pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>
    sys/wasi/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/wasi/os.rs:pub fn env() -> Env {
    sys/wasi/os.rs:pub fn getenv(k: &OsStr) -> Option<OsString> {
    sys/wasi/os.rs:pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {
    sys/wasi/os.rs:pub fn unsetenv(n: &OsStr) -> io::Result<()> {
    sys/wasi/os.rs:pub fn temp_dir() -> PathBuf {
    sys/wasi/os.rs:pub fn home_dir() -> Option<PathBuf> {
    sys/wasi/os.rs:pub fn exit(code: i32) -> ! {
    sys/wasi/os.rs:pub fn getpid() -> u32 {
    sys/wasi/stdio.rs:pub fn is_ebadf(err: &io::Error) -> bool {
    sys/wasi/stdio.rs:pub fn panic_output() -> Option<impl io::Write> {
    sys/wasi/args.rs:pub fn args() -> Args {
    sys/wasi/time.rs:    pub fn now() -> Instant {
    sys/wasi/time.rs:    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
    sys/wasi/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
    sys/wasi/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
    sys/wasi/time.rs:    pub fn now() -> SystemTime {
    sys/wasi/time.rs:    pub fn from_wasi_timestamp(ts: wasi::Timestamp) -> SystemTime {
    sys/wasi/time.rs:    pub fn to_wasi_timestamp(&self) -> Option<wasi::Timestamp> {
    sys/wasi/time.rs:    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {
    sys/wasi/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/wasi/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/wasi/thread.rs:    pub fn yield_now() {
    sys/wasi/thread.rs:    pub fn set_name(_name: &CStr) {
    sys/wasi/thread.rs:    pub fn sleep(dur: Duration) {
    sys/wasi/thread.rs:    pub fn join(self) {
    sys/wasi/thread.rs:pub fn available_parallelism() -> io::Result<NonZeroUsize> {
    sys/wasi/io.rs:    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {
    sys/wasi/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/wasi/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/wasi/io.rs:    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {
    sys/wasi/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/wasi/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/wasi/io.rs:    pub fn as_mut_slice(&mut self) -> &mut [u8] {
    sys/wasi/io.rs:pub fn is_terminal(fd: &impl AsFd) -> bool {
    sys/wasi/fs.rs:    pub fn size(&self) -> u64 {
    sys/wasi/fs.rs:    pub fn perm(&self) -> FilePermissions {
    sys/wasi/fs.rs:    pub fn file_type(&self) -> FileType {
    sys/wasi/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/wasi/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/wasi/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/wasi/fs.rs:    pub fn as_wasi(&self) -> &wasi::Filestat {
    sys/wasi/fs.rs:    pub fn readonly(&self) -> bool {
    sys/wasi/fs.rs:    pub fn set_readonly(&mut self, readonly: bool) {
    sys/wasi/fs.rs:    pub fn set_accessed(&mut self, t: SystemTime) {
    sys/wasi/fs.rs:    pub fn set_modified(&mut self, t: SystemTime) {
    sys/wasi/fs.rs:    pub fn is_dir(&self) -> bool {
    sys/wasi/fs.rs:    pub fn is_file(&self) -> bool {
    sys/wasi/fs.rs:    pub fn is_symlink(&self) -> bool {
    sys/wasi/fs.rs:    pub fn bits(&self) -> wasi::Filetype {
    sys/wasi/fs.rs:    pub fn path(&self) -> PathBuf {
    sys/wasi/fs.rs:    pub fn file_name(&self) -> OsString {
    sys/wasi/fs.rs:    pub fn metadata(&self) -> io::Result<FileAttr> {
    sys/wasi/fs.rs:    pub fn file_type(&self) -> io::Result<FileType> {
    sys/wasi/fs.rs:    pub fn ino(&self) -> wasi::Inode {
    sys/wasi/fs.rs:    pub fn new() -> OpenOptions {
    sys/wasi/fs.rs:    pub fn read(&mut self, read: bool) {
    sys/wasi/fs.rs:    pub fn write(&mut self, write: bool) {
    sys/wasi/fs.rs:    pub fn truncate(&mut self, truncate: bool) {
    sys/wasi/fs.rs:    pub fn create(&mut self, create: bool) {
    sys/wasi/fs.rs:    pub fn create_new(&mut self, create_new: bool) {
    sys/wasi/fs.rs:    pub fn directory(&mut self, directory: bool) {
    sys/wasi/fs.rs:    pub fn append(&mut self, append: bool) {
    sys/wasi/fs.rs:    pub fn dsync(&mut self, set: bool) {
    sys/wasi/fs.rs:    pub fn nonblock(&mut self, set: bool) {
    sys/wasi/fs.rs:    pub fn rsync(&mut self, set: bool) {
    sys/wasi/fs.rs:    pub fn sync(&mut self, set: bool) {
    sys/wasi/fs.rs:    pub fn fs_rights_base(&mut self, rights: wasi::Rights) {
    sys/wasi/fs.rs:    pub fn fs_rights_inheriting(&mut self, rights: wasi::Rights) {
    sys/wasi/fs.rs:    pub fn lookup_flags(&mut self, flags: wasi::Lookupflags) {
    sys/wasi/fs.rs:    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
    sys/wasi/fs.rs:    pub fn open_at(&self, path: &Path, opts: &OpenOptions) -> io::Result<File> {
    sys/wasi/fs.rs:    pub fn file_attr(&self) -> io::Result<FileAttr> {
    sys/wasi/fs.rs:    pub fn metadata_at(&self, flags: wasi::Lookupflags, path: &Path) -> io::Result<FileAttr> {
    sys/wasi/fs.rs:    pub fn fsync(&self) -> io::Result<()> {
    sys/wasi/fs.rs:    pub fn datasync(&self) -> io::Result<()> {
    sys/wasi/fs.rs:    pub fn truncate(&self, size: u64) -> io::Result<()> {
    sys/wasi/fs.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/wasi/fs.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/wasi/fs.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/wasi/fs.rs:    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {
    sys/wasi/fs.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/wasi/fs.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/wasi/fs.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/wasi/fs.rs:    pub fn flush(&self) -> io::Result<()> {
    sys/wasi/fs.rs:    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {
    sys/wasi/fs.rs:    pub fn duplicate(&self) -> io::Result<File> {
    sys/wasi/fs.rs:    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
    sys/wasi/fs.rs:    pub fn set_times(&self, times: FileTimes) -> io::Result<()> {
    sys/wasi/fs.rs:    pub fn read_link(&self, file: &Path) -> io::Result<PathBuf> {
    sys/wasi/fs.rs:    pub fn new() -> DirBuilder {
    sys/wasi/fs.rs:    pub fn mkdir(&self, p: &Path) -> io::Result<()> {
    sys/wasi/fs.rs:pub fn readdir(p: &Path) -> io::Result<ReadDir> {
    sys/wasi/fs.rs:pub fn unlink(p: &Path) -> io::Result<()> {
    sys/wasi/fs.rs:pub fn rename(old: &Path, new: &Path) -> io::Result<()> {
    sys/wasi/fs.rs:pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {
    sys/wasi/fs.rs:pub fn rmdir(p: &Path) -> io::Result<()> {
    sys/wasi/fs.rs:pub fn readlink(p: &Path) -> io::Result<PathBuf> {
    sys/wasi/fs.rs:pub fn symlink(original: &Path, link: &Path) -> io::Result<()> {
    sys/wasi/fs.rs:pub fn link(original: &Path, link: &Path) -> io::Result<()> {
    sys/wasi/fs.rs:pub fn stat(p: &Path) -> io::Result<FileAttr> {
    sys/wasi/fs.rs:pub fn lstat(p: &Path) -> io::Result<FileAttr> {
    sys/wasi/fs.rs:pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {
    sys/wasi/fs.rs:            pub fn __wasilibc_find_relpath(
    sys/wasi/fs.rs:pub fn osstr2str(f: &OsStr) -> io::Result<&str> {
    sys/wasi/fs.rs:pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {
    sys/wasi/fs.rs:pub fn remove_dir_all(path: &Path) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn datasync(&self) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn pread(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {
    sys/wasi/fd.rs:    pub fn pwrite(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {
    sys/wasi/fd.rs:    pub fn read(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/wasi/fd.rs:    pub fn read_buf(&self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn write(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/wasi/fd.rs:    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {
    sys/wasi/fd.rs:    pub fn tell(&self) -> io::Result<u64> {
    sys/wasi/fd.rs:    pub fn set_flags(&self, flags: wasi::Fdflags) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn set_rights(&self, base: wasi::Rights, inheriting: wasi::Rights) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn sync(&self) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn advise(&self, offset: u64, len: u64, advice: wasi::Advice) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn allocate(&self, offset: u64, len: u64) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn create_directory(&self, path: &str) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn link(
    sys/wasi/fd.rs:    pub fn open(
    sys/wasi/fd.rs:    pub fn readdir(&self, buf: &mut [u8], cookie: wasi::Dircookie) -> io::Result<usize> {
    sys/wasi/fd.rs:    pub fn readlink(&self, path: &str, buf: &mut [u8]) -> io::Result<usize> {
    sys/wasi/fd.rs:    pub fn rename(&self, old_path: &str, new_fd: &WasiFd, new_path: &str) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn filestat_get(&self) -> io::Result<wasi::Filestat> {
    sys/wasi/fd.rs:    pub fn filestat_set_times(
    sys/wasi/fd.rs:    pub fn filestat_set_size(&self, size: u64) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn path_filestat_get(
    sys/wasi/fd.rs:    pub fn path_filestat_set_times(
    sys/wasi/fd.rs:    pub fn symlink(&self, old_path: &str, new_path: &str) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn unlink_file(&self, path: &str) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn remove_directory(&self, path: &str) -> io::Result<()> {
    sys/wasi/fd.rs:    pub fn sock_accept(&self, flags: wasi::Fdflags) -> io::Result<wasi::Fd> {
    sys/wasi/fd.rs:    pub fn sock_recv(
    sys/wasi/fd.rs:    pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: wasi::Siflags) -> io::Result<usize> {
    sys/wasi/fd.rs:    pub fn sock_shutdown(&self, how: Shutdown) -> io::Result<()> {
    sys/unix/net.rs:pub fn init() {}
    sys/unix/net.rs:pub fn cvt_gai(err: c_int) -> io::Result<()> {
    sys/unix/net.rs:    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {
    sys/unix/net.rs:    pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {
    sys/unix/net.rs:    pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> {
    sys/unix/net.rs:    pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {
    sys/unix/net.rs:    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {
    sys/unix/net.rs:    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {
    sys/unix/net.rs:    pub fn duplicate(&self) -> io::Result<Socket> {
    sys/unix/net.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/unix/net.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/unix/net.rs:    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/unix/net.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unix/net.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/unix/net.rs:    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/unix/net.rs:    pub fn recv_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {
    sys/unix/net.rs:    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/unix/net.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/unix/net.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unix/net.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/unix/net.rs:    pub fn send_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {
    sys/unix/net.rs:    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {
    sys/unix/net.rs:    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> {
    sys/unix/net.rs:    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
    sys/unix/net.rs:    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {
    sys/unix/net.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/unix/net.rs:    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {
    sys/unix/net.rs:    pub fn nodelay(&self) -> io::Result<bool> {
    sys/unix/net.rs:    pub fn set_quickack(&self, quickack: bool) -> io::Result<()> {
    sys/unix/net.rs:    pub fn quickack(&self) -> io::Result<bool> {
    sys/unix/net.rs:    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {
    sys/unix/net.rs:    pub fn passcred(&self) -> io::Result<bool> {
    sys/unix/net.rs:    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {
    sys/unix/net.rs:    pub fn passcred(&self) -> io::Result<bool> {
    sys/unix/net.rs:    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {
    sys/unix/net.rs:    pub fn passcred(&self) -> io::Result<bool> {
    sys/unix/net.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys/unix/net.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys/unix/net.rs:    pub fn set_mark(&self, mark: u32) -> io::Result<()> {
    sys/unix/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/unix/net.rs:    pub fn as_raw(&self) -> RawFd {
    sys/unix/os_str.rs:    pub fn from_string(s: String) -> Buf {
    sys/unix/os_str.rs:    pub fn with_capacity(capacity: usize) -> Buf {
    sys/unix/os_str.rs:    pub fn clear(&mut self) {
    sys/unix/os_str.rs:    pub fn capacity(&self) -> usize {
    sys/unix/os_str.rs:    pub fn reserve(&mut self, additional: usize) {
    sys/unix/os_str.rs:    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
    sys/unix/os_str.rs:    pub fn reserve_exact(&mut self, additional: usize) {
    sys/unix/os_str.rs:    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
    sys/unix/os_str.rs:    pub fn shrink_to_fit(&mut self) {
    sys/unix/os_str.rs:    pub fn shrink_to(&mut self, min_capacity: usize) {
    sys/unix/os_str.rs:    pub fn as_slice(&self) -> &Slice {
    sys/unix/os_str.rs:    pub fn as_mut_slice(&mut self) -> &mut Slice {
    sys/unix/os_str.rs:    pub fn into_string(self) -> Result<String, Buf> {
    sys/unix/os_str.rs:    pub fn push_slice(&mut self, s: &Slice) {
    sys/unix/os_str.rs:    pub fn into_box(self) -> Box<Slice> {
    sys/unix/os_str.rs:    pub fn from_box(boxed: Box<Slice>) -> Buf {
    sys/unix/os_str.rs:    pub fn into_arc(&self) -> Arc<Slice> {
    sys/unix/os_str.rs:    pub fn into_rc(&self) -> Rc<Slice> {
    sys/unix/os_str.rs:    pub fn from_str(s: &str) -> &Slice {
    sys/unix/os_str.rs:    pub fn to_str(&self) -> Option<&str> {
    sys/unix/os_str.rs:    pub fn to_string_lossy(&self) -> Cow<'_, str> {
    sys/unix/os_str.rs:    pub fn to_owned(&self) -> Buf {
    sys/unix/os_str.rs:    pub fn clone_into(&self, buf: &mut Buf) {
    sys/unix/os_str.rs:    pub fn into_box(&self) -> Box<Slice> {
    sys/unix/os_str.rs:    pub fn empty_box() -> Box<Slice> {
    sys/unix/os_str.rs:    pub fn into_arc(&self) -> Arc<Slice> {
    sys/unix/os_str.rs:    pub fn into_rc(&self) -> Rc<Slice> {
    sys/unix/os_str.rs:    pub fn make_ascii_lowercase(&mut self) {
    sys/unix/os_str.rs:    pub fn make_ascii_uppercase(&mut self) {
    sys/unix/os_str.rs:    pub fn to_ascii_lowercase(&self) -> Buf {
    sys/unix/os_str.rs:    pub fn to_ascii_uppercase(&self) -> Buf {
    sys/unix/os_str.rs:    pub fn is_ascii(&self) -> bool {
    sys/unix/os_str.rs:    pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool {
    sys/unix/thread_parking/pthread.rs:    pub fn unpark(self: Pin<&Self>) {
    sys/unix/thread_parking/netbsd.rs:pub fn current() -> ThreadId {
    sys/unix/thread_parking/netbsd.rs:pub fn park(hint: usize) {
    sys/unix/thread_parking/netbsd.rs:pub fn park_timeout(dur: Duration, hint: usize) {
    sys/unix/thread_parking/netbsd.rs:pub fn unpark(tid: ThreadId, hint: usize) {
    sys/unix/thread_parking/darwin.rs:    pub fn unpark(self: Pin<&Self>) {
    sys/unix/futex.rs:pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {
    sys/unix/futex.rs:pub fn futex_wake(futex: &AtomicU32) -> bool {
    sys/unix/futex.rs:pub fn futex_wake_all(futex: &AtomicU32) {
    sys/unix/futex.rs:pub fn futex_wake(futex: &AtomicU32) -> bool {
    sys/unix/futex.rs:pub fn futex_wake_all(futex: &AtomicU32) {
    sys/unix/futex.rs:pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {
    sys/unix/futex.rs:pub fn futex_wake(futex: &AtomicU32) -> bool {
    sys/unix/futex.rs:pub fn futex_wake_all(futex: &AtomicU32) {
    sys/unix/futex.rs:pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {
    sys/unix/futex.rs:pub fn futex_wake(futex: &AtomicU32) -> bool {
    sys/unix/futex.rs:pub fn futex_wake_all(futex: &AtomicU32) {
    sys/unix/futex.rs:pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {
    sys/unix/futex.rs:pub fn futex_wake(futex: &AtomicU32) -> bool {
    sys/unix/futex.rs:pub fn futex_wake_all(futex: &AtomicU32) {
    sys/unix/futex.rs:        pub fn zx_clock_get_monotonic() -> zx_time_t;
    sys/unix/futex.rs:        pub fn zx_futex_wait(
    sys/unix/futex.rs:        pub fn zx_futex_wake(value_ptr: *const zx_futex_t, wake_count: u32) -> zx_status_t;
    sys/unix/futex.rs:        pub fn zx_futex_wake_single_owner(value_ptr: *const zx_futex_t) -> zx_status_t;
    sys/unix/futex.rs:        pub fn zx_thread_self() -> zx_handle_t;
    sys/unix/futex.rs:pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {
    sys/unix/futex.rs:pub fn futex_wake(futex: &AtomicU32) -> bool {
    sys/unix/futex.rs:pub fn futex_wake_all(futex: &AtomicU32) {
    sys/unix/mod.rs:pub fn init(argc: isize, argv: *const *const u8, _sigpipe: u8) {}
    sys/unix/mod.rs:pub fn decode_error_kind(errno: i32) -> ErrorKind {
    sys/unix/mod.rs:pub fn cvt<T: IsMinusOne>(t: T) -> crate::io::Result<T> {
    sys/unix/mod.rs:pub fn cvt_r<T, F>(mut f: F) -> crate::io::Result<T>
    sys/unix/mod.rs:pub fn cvt_nz(error: libc::c_int) -> crate::io::Result<()> {
    sys/unix/mod.rs:pub fn abort_internal() -> ! {
    sys/unix/mod.rs:    pub fn unsupported<T>() -> io::Result<T> {
    sys/unix/mod.rs:    pub fn unsupported_err() -> io::Error {
    sys/unix/path.rs:pub fn is_sep_byte(b: u8) -> bool {
    sys/unix/path.rs:pub fn is_verbatim_sep(b: u8) -> bool {
    sys/unix/path.rs:pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {
    sys/unix/locks/futex_condvar.rs:    pub fn notify_one(&self) {
    sys/unix/locks/futex_condvar.rs:    pub fn notify_all(&self) {
    sys/unix/locks/pthread_rwlock.rs:    pub fn read(&self) {
    sys/unix/locks/pthread_rwlock.rs:    pub fn try_read(&self) -> bool {
    sys/unix/locks/pthread_rwlock.rs:    pub fn write(&self) {
    sys/unix/locks/futex_rwlock.rs:    pub fn try_read(&self) -> bool {
    sys/unix/locks/futex_rwlock.rs:    pub fn read(&self) {
    sys/unix/locks/futex_rwlock.rs:    pub fn try_write(&self) -> bool {
    sys/unix/locks/futex_rwlock.rs:    pub fn write(&self) {
    sys/unix/locks/futex_mutex.rs:    pub fn try_lock(&self) -> bool {
    sys/unix/locks/futex_mutex.rs:    pub fn lock(&self) {
    sys/unix/locks/pthread_condvar.rs:    pub fn notify_one(&self) {
    sys/unix/locks/pthread_condvar.rs:    pub fn notify_all(&self) {
    sys/unix/locks/fuchsia_mutex.rs:    pub fn try_lock(&self) -> bool {
    sys/unix/locks/fuchsia_mutex.rs:    pub fn lock(&self) {
    sys/unix/os.rs:pub fn errno() -> i32 {
    sys/unix/os.rs:pub fn set_errno(e: i32) {
    sys/unix/os.rs:pub fn errno() -> i32 {
    sys/unix/os.rs:pub fn errno() -> i32 {
    sys/unix/os.rs:pub fn set_errno(e: i32) {
    sys/unix/os.rs:pub fn error_string(errno: i32) -> String {
    sys/unix/os.rs:pub fn getcwd() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn getcwd() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn chdir(p: &path::Path) -> io::Result<()> {
    sys/unix/os.rs:pub fn chdir(p: &path::Path) -> io::Result<()> {
    sys/unix/os.rs:pub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {
    sys/unix/os.rs:pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unix/os.rs:pub fn env_read_lock() -> impl Drop {
    sys/unix/os.rs:pub fn env() -> Env {
    sys/unix/os.rs:pub fn getenv(k: &OsStr) -> Option<OsString> {
    sys/unix/os.rs:pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {
    sys/unix/os.rs:pub fn unsetenv(n: &OsStr) -> io::Result<()> {
    sys/unix/os.rs:pub fn page_size() -> usize {
    sys/unix/os.rs:pub fn temp_dir() -> PathBuf {
    sys/unix/os.rs:pub fn home_dir() -> Option<PathBuf> {
    sys/unix/os.rs:pub fn exit(code: i32) -> ! {
    sys/unix/os.rs:pub fn getpid() -> u32 {
    sys/unix/os.rs:pub fn getppid() -> u32 {
    sys/unix/os.rs:pub fn glibc_version() -> Option<(usize, usize)> {
    sys/unix/stdio.rs:pub fn is_ebadf(err: &io::Error) -> bool {
    sys/unix/stdio.rs:pub fn panic_output() -> Option<impl io::Write> {
    sys/unix/process/process_vxworks.rs:    pub fn spawn(
    sys/unix/process/process_vxworks.rs:    pub fn output(&mut self) -> io::Result<(ExitStatus, Vec<u8>, Vec<u8>)> {
    sys/unix/process/process_vxworks.rs:    pub fn exec(&mut self, default: Stdio) -> io::Error {
    sys/unix/process/process_vxworks.rs:    pub fn id(&self) -> u32 {
    sys/unix/process/process_vxworks.rs:    pub fn kill(&mut self) -> io::Result<()> {
    sys/unix/process/process_vxworks.rs:    pub fn wait(&mut self) -> io::Result<ExitStatus> {
    sys/unix/process/process_vxworks.rs:    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
    sys/unix/process/process_vxworks.rs:    pub fn new(status: c_int) -> ExitStatus {
    sys/unix/process/process_vxworks.rs:    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {
    sys/unix/process/process_vxworks.rs:    pub fn code(&self) -> Option<i32> {
    sys/unix/process/process_vxworks.rs:    pub fn signal(&self) -> Option<i32> {
    sys/unix/process/process_vxworks.rs:    pub fn core_dumped(&self) -> bool {
    sys/unix/process/process_vxworks.rs:    pub fn stopped_signal(&self) -> Option<i32> {
    sys/unix/process/process_vxworks.rs:    pub fn continued(&self) -> bool {
    sys/unix/process/process_vxworks.rs:    pub fn into_raw(&self) -> c_int {
    sys/unix/process/process_vxworks.rs:    pub fn code(self) -> Option<NonZeroI32> {
    sys/unix/process/process_unsupported.rs:    pub fn spawn(
    sys/unix/process/process_unsupported.rs:    pub fn output(&mut self) -> io::Result<(ExitStatus, Vec<u8>, Vec<u8>)> {
    sys/unix/process/process_unsupported.rs:    pub fn exec(&mut self, _default: Stdio) -> io::Error {
    sys/unix/process/process_unsupported.rs:    pub fn id(&self) -> u32 {
    sys/unix/process/process_unsupported.rs:    pub fn kill(&mut self) -> io::Result<()> {
    sys/unix/process/process_unsupported.rs:    pub fn wait(&mut self) -> io::Result<ExitStatus> {
    sys/unix/process/process_unsupported.rs:    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
    sys/unix/process/process_unsupported.rs:    pub fn success(&self) -> bool {
    sys/unix/process/process_unsupported.rs:    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {
    sys/unix/process/process_unsupported.rs:    pub fn code(&self) -> Option<i32> {
    sys/unix/process/process_unsupported.rs:    pub fn signal(&self) -> Option<i32> {
    sys/unix/process/process_unsupported.rs:    pub fn core_dumped(&self) -> bool {
    sys/unix/process/process_unsupported.rs:    pub fn stopped_signal(&self) -> Option<i32> {
    sys/unix/process/process_unsupported.rs:    pub fn continued(&self) -> bool {
    sys/unix/process/process_unsupported.rs:    pub fn into_raw(&self) -> c_int {
    sys/unix/process/process_unsupported.rs:    pub fn code(self) -> Option<NonZeroI32> {
    sys/unix/process/zircon.rs:pub fn zx_cvt<T>(t: T) -> io::Result<T>
    sys/unix/process/zircon.rs:    pub fn new(raw: zx_handle_t) -> Handle {
    sys/unix/process/zircon.rs:    pub fn raw(&self) -> zx_handle_t {
    sys/unix/process/zircon.rs:    pub fn zx_job_default() -> zx_handle_t;
    sys/unix/process/zircon.rs:    pub fn zx_task_kill(handle: zx_handle_t) -> zx_status_t;
    sys/unix/process/zircon.rs:    pub fn zx_handle_close(handle: zx_handle_t) -> zx_status_t;
    sys/unix/process/zircon.rs:    pub fn zx_handle_duplicate(
    sys/unix/process/zircon.rs:    pub fn zx_object_wait_one(
    sys/unix/process/zircon.rs:    pub fn zx_object_get_info(
    sys/unix/process/zircon.rs:    pub fn fdio_spawn_etc(
    sys/unix/process/zircon.rs:    pub fn fdio_fd_clone(fd: c_int, out_handle: *mut zx_handle_t) -> zx_status_t;
    sys/unix/process/zircon.rs:    pub fn fdio_fd_create(handle: zx_handle_t, fd: *mut c_int) -> zx_status_t;
    sys/unix/process/process_common.rs:    pub fn new(program: &OsStr) -> Command {
    sys/unix/process/process_common.rs:    pub fn new(program: &OsStr) -> Command {
    sys/unix/process/process_common.rs:    pub fn set_arg_0(&mut self, arg: &OsStr) {
    sys/unix/process/process_common.rs:    pub fn arg(&mut self, arg: &OsStr) {
    sys/unix/process/process_common.rs:    pub fn cwd(&mut self, dir: &OsStr) {
    sys/unix/process/process_common.rs:    pub fn uid(&mut self, id: uid_t) {
    sys/unix/process/process_common.rs:    pub fn gid(&mut self, id: gid_t) {
    sys/unix/process/process_common.rs:    pub fn groups(&mut self, groups: &[gid_t]) {
    sys/unix/process/process_common.rs:    pub fn pgroup(&mut self, pgroup: pid_t) {
    sys/unix/process/process_common.rs:    pub fn create_pidfd(&mut self, val: bool) {
    sys/unix/process/process_common.rs:    pub fn get_create_pidfd(&self) -> bool {
    sys/unix/process/process_common.rs:    pub fn get_create_pidfd(&self) -> bool {
    sys/unix/process/process_common.rs:    pub fn saw_nul(&self) -> bool {
    sys/unix/process/process_common.rs:    pub fn get_program(&self) -> &OsStr {
    sys/unix/process/process_common.rs:    pub fn get_program_kind(&self) -> ProgramKind {
    sys/unix/process/process_common.rs:    pub fn get_args(&self) -> CommandArgs<'_> {
    sys/unix/process/process_common.rs:    pub fn get_envs(&self) -> CommandEnvs<'_> {
    sys/unix/process/process_common.rs:    pub fn get_current_dir(&self) -> Option<&Path> {
    sys/unix/process/process_common.rs:    pub fn get_argv(&self) -> &Vec<*const c_char> {
    sys/unix/process/process_common.rs:    pub fn get_program_cstr(&self) -> &CStr {
    sys/unix/process/process_common.rs:    pub fn get_cwd(&self) -> &Option<CString> {
    sys/unix/process/process_common.rs:    pub fn get_uid(&self) -> Option<uid_t> {
    sys/unix/process/process_common.rs:    pub fn get_gid(&self) -> Option<gid_t> {
    sys/unix/process/process_common.rs:    pub fn get_groups(&self) -> Option<&[gid_t]> {
    sys/unix/process/process_common.rs:    pub fn get_pgroup(&self) -> Option<pid_t> {
    sys/unix/process/process_common.rs:    pub fn get_closures(&mut self) -> &mut Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>> {
    sys/unix/process/process_common.rs:    pub fn stdin(&mut self, stdin: Stdio) {
    sys/unix/process/process_common.rs:    pub fn stdout(&mut self, stdout: Stdio) {
    sys/unix/process/process_common.rs:    pub fn stderr(&mut self, stderr: Stdio) {
    sys/unix/process/process_common.rs:    pub fn env_mut(&mut self) -> &mut CommandEnv {
    sys/unix/process/process_common.rs:    pub fn capture_env(&mut self) -> Option<CStringArray> {
    sys/unix/process/process_common.rs:    pub fn env_saw_path(&self) -> bool {
    sys/unix/process/process_common.rs:    pub fn program_is_path(&self) -> bool {
    sys/unix/process/process_common.rs:    pub fn setup_io(
    sys/unix/process/process_common.rs:    pub fn with_capacity(capacity: usize) -> Self {
    sys/unix/process/process_common.rs:    pub fn push(&mut self, item: CString) {
    sys/unix/process/process_common.rs:    pub fn as_ptr(&self) -> *const *const c_char {
    sys/unix/process/process_common.rs:    pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {
    sys/unix/process/process_common.rs:    pub fn fd(&self) -> Option<c_int> {
    sys/unix/process/process_common.rs:    pub fn as_i32(&self) -> i32 {
    sys/unix/process/process_fuchsia.rs:    pub fn spawn(
    sys/unix/process/process_fuchsia.rs:    pub fn output(&mut self) -> io::Result<(ExitStatus, Vec<u8>, Vec<u8>)> {
    sys/unix/process/process_fuchsia.rs:    pub fn exec(&mut self, default: Stdio) -> io::Error {
    sys/unix/process/process_fuchsia.rs:    pub fn id(&self) -> u32 {
    sys/unix/process/process_fuchsia.rs:    pub fn kill(&mut self) -> io::Result<()> {
    sys/unix/process/process_fuchsia.rs:    pub fn wait(&mut self) -> io::Result<ExitStatus> {
    sys/unix/process/process_fuchsia.rs:    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
    sys/unix/process/process_fuchsia.rs:    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {
    sys/unix/process/process_fuchsia.rs:    pub fn code(&self) -> Option<i32> {
    sys/unix/process/process_fuchsia.rs:    pub fn signal(&self) -> Option<i32> {
    sys/unix/process/process_fuchsia.rs:    pub fn core_dumped(&self) -> bool {
    sys/unix/process/process_fuchsia.rs:    pub fn stopped_signal(&self) -> Option<i32> {
    sys/unix/process/process_fuchsia.rs:    pub fn continued(&self) -> bool {
    sys/unix/process/process_fuchsia.rs:    pub fn into_raw(&self) -> c_int {
    sys/unix/process/process_fuchsia.rs:    pub fn code(self) -> Option<NonZeroI32> {
    sys/unix/process/process_unix.rs:    pub fn spawn(
    sys/unix/process/process_unix.rs:    pub fn output(&mut self) -> io::Result<(ExitStatus, Vec<u8>, Vec<u8>)> {
    sys/unix/process/process_unix.rs:    pub fn exec(&mut self, default: Stdio) -> io::Error {
    sys/unix/process/process_unix.rs:    pub fn id(&self) -> u32 {
    sys/unix/process/process_unix.rs:    pub fn kill(&mut self) -> io::Result<()> {
    sys/unix/process/process_unix.rs:    pub fn wait(&mut self) -> io::Result<ExitStatus> {
    sys/unix/process/process_unix.rs:    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
    sys/unix/process/process_unix.rs:    pub fn new(status: c_int) -> ExitStatus {
    sys/unix/process/process_unix.rs:    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {
    sys/unix/process/process_unix.rs:    pub fn code(&self) -> Option<i32> {
    sys/unix/process/process_unix.rs:    pub fn signal(&self) -> Option<i32> {
    sys/unix/process/process_unix.rs:    pub fn core_dumped(&self) -> bool {
    sys/unix/process/process_unix.rs:    pub fn stopped_signal(&self) -> Option<i32> {
    sys/unix/process/process_unix.rs:    pub fn continued(&self) -> bool {
    sys/unix/process/process_unix.rs:    pub fn into_raw(&self) -> c_int {
    sys/unix/process/process_unix.rs:    pub fn code(self) -> Option<NonZeroI32> {
    sys/unix/cmath.rs:    pub fn acos(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn acosf(n: f32) -> f32;
    sys/unix/cmath.rs:    pub fn asin(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn asinf(n: f32) -> f32;
    sys/unix/cmath.rs:    pub fn atan(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn atan2(a: f64, b: f64) -> f64;
    sys/unix/cmath.rs:    pub fn atan2f(a: f32, b: f32) -> f32;
    sys/unix/cmath.rs:    pub fn atanf(n: f32) -> f32;
    sys/unix/cmath.rs:    pub fn cbrt(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn cbrtf(n: f32) -> f32;
    sys/unix/cmath.rs:    pub fn cosh(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn coshf(n: f32) -> f32;
    sys/unix/cmath.rs:    pub fn expm1(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn expm1f(n: f32) -> f32;
    sys/unix/cmath.rs:    pub fn fdim(a: f64, b: f64) -> f64;
    sys/unix/cmath.rs:    pub fn fdimf(a: f32, b: f32) -> f32;
    sys/unix/cmath.rs:    pub fn hypot(x: f64, y: f64) -> f64;
    sys/unix/cmath.rs:    pub fn hypotf(x: f32, y: f32) -> f32;
    sys/unix/cmath.rs:    pub fn log1p(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn log1pf(n: f32) -> f32;
    sys/unix/cmath.rs:    pub fn sinh(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn sinhf(n: f32) -> f32;
    sys/unix/cmath.rs:    pub fn tan(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn tanf(n: f32) -> f32;
    sys/unix/cmath.rs:    pub fn tanh(n: f64) -> f64;
    sys/unix/cmath.rs:    pub fn tanhf(n: f32) -> f32;
    sys/unix/args.rs:pub fn args() -> Args {
    sys/unix/args.rs:    pub fn args() -> Args {
    sys/unix/args.rs:    pub fn args() -> Args {
    sys/unix/args.rs:    pub fn args() -> Args {
    sys/unix/args.rs:    pub fn args() -> Args {
    sys/unix/memchr.rs:pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {
    sys/unix/memchr.rs:pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {
    sys/unix/time.rs:    pub fn new(tv_sec: i64, tv_nsec: i64) -> SystemTime {
    sys/unix/time.rs:    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {
    sys/unix/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/unix/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/unix/time.rs:    pub fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {
    sys/unix/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {
    sys/unix/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {
    sys/unix/time.rs:    pub fn to_timespec(&self) -> Option<libc::timespec> {
    sys/unix/time.rs:        pub fn now() -> Instant {
    sys/unix/time.rs:        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
    sys/unix/time.rs:        pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
    sys/unix/time.rs:        pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
    sys/unix/time.rs:        pub fn now() -> SystemTime {
    sys/unix/time.rs:        pub fn now() -> Instant {
    sys/unix/time.rs:        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
    sys/unix/time.rs:        pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
    sys/unix/time.rs:        pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
    sys/unix/time.rs:        pub fn now() -> SystemTime {
    sys/unix/time.rs:        pub fn now(clock: libc::clockid_t) -> Timespec {
    sys/unix/thread.rs:        pub fn zx_object_set_property(
    sys/unix/thread.rs:        pub fn zx_thread_self() -> zx_handle_t;
    sys/unix/thread.rs:    pub fn yield_now() {
    sys/unix/thread.rs:    pub fn set_name(name: &CStr) {
    sys/unix/thread.rs:    pub fn set_name(name: &CStr) {
    sys/unix/thread.rs:    pub fn set_name(name: &CStr) {
    sys/unix/thread.rs:    pub fn set_name(name: &CStr) {
    sys/unix/thread.rs:    pub fn set_name(name: &CStr) {
    sys/unix/thread.rs:    pub fn set_name(name: &CStr) {
    sys/unix/thread.rs:    pub fn set_name(name: &CStr) {
    sys/unix/thread.rs:    pub fn set_name(name: &CStr) {
    sys/unix/thread.rs:    pub fn set_name(_name: &CStr) {
    sys/unix/thread.rs:    pub fn sleep(dur: Duration) {
    sys/unix/thread.rs:    pub fn sleep(dur: Duration) {
    sys/unix/thread.rs:    pub fn join(self) {
    sys/unix/thread.rs:    pub fn id(&self) -> libc::pthread_t {
    sys/unix/thread.rs:    pub fn into_id(self) -> libc::pthread_t {
    sys/unix/thread.rs:pub fn available_parallelism() -> io::Result<NonZeroUsize> {
    sys/unix/rand.rs:pub fn hashmap_random_keys() -> (u64, u64) {
    sys/unix/rand.rs:    pub fn fill_bytes(v: &mut [u8]) {
    sys/unix/rand.rs:    pub fn fill_bytes(v: &mut [u8]) {
    sys/unix/rand.rs:    pub fn fill_bytes(v: &mut [u8]) {
    sys/unix/rand.rs:    pub fn fill_bytes(v: &mut [u8]) {
    sys/unix/rand.rs:    pub fn fill_bytes(v: &mut [u8]) {
    sys/unix/rand.rs:    pub fn fill_bytes(v: &mut [u8]) {
    sys/unix/rand.rs:    pub fn fill_bytes(v: &mut [u8]) {
    sys/unix/rand.rs:    pub fn fill_bytes(v: &mut [u8]) {
    sys/unix/io.rs:    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {
    sys/unix/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/unix/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/unix/io.rs:    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {
    sys/unix/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/unix/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/unix/io.rs:    pub fn as_mut_slice(&mut self) -> &mut [u8] {
    sys/unix/io.rs:pub fn is_terminal(fd: &impl AsFd) -> bool {
    sys/unix/fs.rs:        pub fn stx_mtime(&self) -> Option<&libc::statx_timestamp> {
    sys/unix/fs.rs:        pub fn stx_atime(&self) -> Option<&libc::statx_timestamp> {
    sys/unix/fs.rs:        pub fn stx_ctime(&self) -> Option<&libc::statx_timestamp> {
    sys/unix/fs.rs:    pub fn size(&self) -> u64 {
    sys/unix/fs.rs:    pub fn perm(&self) -> FilePermissions {
    sys/unix/fs.rs:    pub fn file_type(&self) -> FileType {
    sys/unix/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/unix/fs.rs:    pub fn readonly(&self) -> bool {
    sys/unix/fs.rs:    pub fn set_readonly(&mut self, readonly: bool) {
    sys/unix/fs.rs:    pub fn mode(&self) -> u32 {
    sys/unix/fs.rs:    pub fn set_accessed(&mut self, t: SystemTime) {
    sys/unix/fs.rs:    pub fn set_modified(&mut self, t: SystemTime) {
    sys/unix/fs.rs:    pub fn is_dir(&self) -> bool {
    sys/unix/fs.rs:    pub fn is_file(&self) -> bool {
    sys/unix/fs.rs:    pub fn is_symlink(&self) -> bool {
    sys/unix/fs.rs:    pub fn is(&self, mode: mode_t) -> bool {
    sys/unix/fs.rs:    pub fn path(&self) -> PathBuf {
    sys/unix/fs.rs:    pub fn file_name(&self) -> OsString {
    sys/unix/fs.rs:    pub fn metadata(&self) -> io::Result<FileAttr> {
    sys/unix/fs.rs:    pub fn metadata(&self) -> io::Result<FileAttr> {
    sys/unix/fs.rs:    pub fn file_type(&self) -> io::Result<FileType> {
    sys/unix/fs.rs:    pub fn file_type(&self) -> io::Result<FileType> {
    sys/unix/fs.rs:    pub fn ino(&self) -> u64 {
    sys/unix/fs.rs:    pub fn ino(&self) -> u64 {
    sys/unix/fs.rs:    pub fn file_name_os_str(&self) -> &OsStr {
    sys/unix/fs.rs:    pub fn new() -> OpenOptions {
    sys/unix/fs.rs:    pub fn read(&mut self, read: bool) {
    sys/unix/fs.rs:    pub fn write(&mut self, write: bool) {
    sys/unix/fs.rs:    pub fn append(&mut self, append: bool) {
    sys/unix/fs.rs:    pub fn truncate(&mut self, truncate: bool) {
    sys/unix/fs.rs:    pub fn create(&mut self, create: bool) {
    sys/unix/fs.rs:    pub fn create_new(&mut self, create_new: bool) {
    sys/unix/fs.rs:    pub fn custom_flags(&mut self, flags: i32) {
    sys/unix/fs.rs:    pub fn mode(&mut self, mode: u32) {
    sys/unix/fs.rs:    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
    sys/unix/fs.rs:    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {
    sys/unix/fs.rs:    pub fn file_attr(&self) -> io::Result<FileAttr> {
    sys/unix/fs.rs:    pub fn fsync(&self) -> io::Result<()> {
    sys/unix/fs.rs:    pub fn datasync(&self) -> io::Result<()> {
    sys/unix/fs.rs:    pub fn truncate(&self, size: u64) -> io::Result<()> {
    sys/unix/fs.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/unix/fs.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unix/fs.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/unix/fs.rs:    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {
    sys/unix/fs.rs:    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {
    sys/unix/fs.rs:    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fs.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/unix/fs.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unix/fs.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/unix/fs.rs:    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {
    sys/unix/fs.rs:    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fs.rs:    pub fn flush(&self) -> io::Result<()> {
    sys/unix/fs.rs:    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {
    sys/unix/fs.rs:    pub fn duplicate(&self) -> io::Result<File> {
    sys/unix/fs.rs:    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {
    sys/unix/fs.rs:    pub fn set_times(&self, times: FileTimes) -> io::Result<()> {
    sys/unix/fs.rs:    pub fn new() -> DirBuilder {
    sys/unix/fs.rs:    pub fn mkdir(&self, p: &Path) -> io::Result<()> {
    sys/unix/fs.rs:    pub fn set_mode(&mut self, mode: u32) {
    sys/unix/fs.rs:pub fn readdir(path: &Path) -> io::Result<ReadDir> {
    sys/unix/fs.rs:pub fn unlink(p: &Path) -> io::Result<()> {
    sys/unix/fs.rs:pub fn rename(old: &Path, new: &Path) -> io::Result<()> {
    sys/unix/fs.rs:pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {
    sys/unix/fs.rs:pub fn rmdir(p: &Path) -> io::Result<()> {
    sys/unix/fs.rs:pub fn readlink(p: &Path) -> io::Result<PathBuf> {
    sys/unix/fs.rs:pub fn symlink(original: &Path, link: &Path) -> io::Result<()> {
    sys/unix/fs.rs:pub fn link(original: &Path, link: &Path) -> io::Result<()> {
    sys/unix/fs.rs:pub fn stat(p: &Path) -> io::Result<FileAttr> {
    sys/unix/fs.rs:pub fn lstat(p: &Path) -> io::Result<FileAttr> {
    sys/unix/fs.rs:pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {
    sys/unix/fs.rs:pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {
    sys/unix/fs.rs:pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {
    sys/unix/fs.rs:pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {
    sys/unix/fs.rs:pub fn chown(path: &Path, uid: u32, gid: u32) -> io::Result<()> {
    sys/unix/fs.rs:pub fn fchown(fd: c_int, uid: u32, gid: u32) -> io::Result<()> {
    sys/unix/fs.rs:pub fn lchown(path: &Path, uid: u32, gid: u32) -> io::Result<()> {
    sys/unix/fs.rs:pub fn chroot(dir: &Path) -> io::Result<()> {
    sys/unix/fs.rs:        pub fn has_openat() -> bool {
    sys/unix/fs.rs:    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {
    sys/unix/fs.rs:    pub fn remove_dir_all(p: &Path) -> io::Result<()> {
    sys/unix/fs.rs:    pub fn remove_dir_all(p: &Path) -> io::Result<()> {
    sys/unix/android.rs:pub fn log2f32(f: f32) -> f32 {
    sys/unix/android.rs:pub fn log2f64(f: f64) -> f64 {
    sys/unix/pipe.rs:pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {
    sys/unix/pipe.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/unix/pipe.rs:    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/unix/pipe.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unix/pipe.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/unix/pipe.rs:    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {
    sys/unix/pipe.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/unix/pipe.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unix/pipe.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/unix/pipe.rs:pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn new(_: &SocketAddr, _: libc::c_int) -> io::Result<Socket> {
    sys/unix/l4re.rs:        pub fn new_raw(_: libc::c_int, _: libc::c_int) -> io::Result<Socket> {
    sys/unix/l4re.rs:        pub fn new_pair(_: libc::c_int, _: libc::c_int) -> io::Result<(Socket, Socket)> {
    sys/unix/l4re.rs:        pub fn connect_timeout(&self, _: &SocketAddr, _: Duration) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn accept(
    sys/unix/l4re.rs:        pub fn duplicate(&self) -> io::Result<Socket> {
    sys/unix/l4re.rs:        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn is_read_vectored(&self) -> bool {
    sys/unix/l4re.rs:        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/unix/l4re.rs:        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/unix/l4re.rs:        pub fn write(&self, _: &[u8]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn is_write_vectored(&self) -> bool {
    sys/unix/l4re.rs:        pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn timeout(&self, _: libc::c_int) -> io::Result<Option<Duration>> {
    sys/unix/l4re.rs:        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/unix/l4re.rs:        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn nodelay(&self) -> io::Result<bool> {
    sys/unix/l4re.rs:        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/unix/l4re.rs:        pub fn as_raw(&self) -> RawFd {
    sys/unix/l4re.rs:        pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
    sys/unix/l4re.rs:        pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {
    sys/unix/l4re.rs:        pub fn socket(&self) -> &Socket {
    sys/unix/l4re.rs:        pub fn into_socket(self) -> Socket {
    sys/unix/l4re.rs:        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/unix/l4re.rs:        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/unix/l4re.rs:        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn is_read_vectored(&self) -> bool {
    sys/unix/l4re.rs:        pub fn write(&self, _: &[u8]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn is_write_vectored(&self) -> bool {
    sys/unix/l4re.rs:        pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/unix/l4re.rs:        pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/unix/l4re.rs:        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn duplicate(&self) -> io::Result<TcpStream> {
    sys/unix/l4re.rs:        pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/unix/l4re.rs:        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn nodelay(&self) -> io::Result<bool> {
    sys/unix/l4re.rs:        pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn ttl(&self) -> io::Result<u32> {
    sys/unix/l4re.rs:        pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/unix/l4re.rs:        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
    sys/unix/l4re.rs:        pub fn socket(&self) -> &Socket {
    sys/unix/l4re.rs:        pub fn into_socket(self) -> Socket {
    sys/unix/l4re.rs:        pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/unix/l4re.rs:        pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {
    sys/unix/l4re.rs:        pub fn duplicate(&self) -> io::Result<TcpListener> {
    sys/unix/l4re.rs:        pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn ttl(&self) -> io::Result<u32> {
    sys/unix/l4re.rs:        pub fn set_only_v6(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn only_v6(&self) -> io::Result<bool> {
    sys/unix/l4re.rs:        pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/unix/l4re.rs:        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {
    sys/unix/l4re.rs:        pub fn socket(&self) -> &Socket {
    sys/unix/l4re.rs:        pub fn into_socket(self) -> Socket {
    sys/unix/l4re.rs:        pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/unix/l4re.rs:        pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/unix/l4re.rs:        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/unix/l4re.rs:        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/unix/l4re.rs:        pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn duplicate(&self) -> io::Result<UdpSocket> {
    sys/unix/l4re.rs:        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/unix/l4re.rs:        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/unix/l4re.rs:        pub fn set_broadcast(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn broadcast(&self) -> io::Result<bool> {
    sys/unix/l4re.rs:        pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn multicast_loop_v4(&self) -> io::Result<bool> {
    sys/unix/l4re.rs:        pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn multicast_ttl_v4(&self) -> io::Result<u32> {
    sys/unix/l4re.rs:        pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn multicast_loop_v6(&self) -> io::Result<bool> {
    sys/unix/l4re.rs:        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn ttl(&self) -> io::Result<u32> {
    sys/unix/l4re.rs:        pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/unix/l4re.rs:        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn send(&self, _: &[u8]) -> io::Result<usize> {
    sys/unix/l4re.rs:        pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {
    sys/unix/l4re.rs:        pub fn port(&self) -> u16 {
    sys/unix/fd.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/unix/fd.rs:    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn read_buf(&self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {
    sys/unix/fd.rs:    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/unix/fd.rs:    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {
    sys/unix/fd.rs:    pub fn set_cloexec(&self) -> io::Result<()> {
    sys/unix/fd.rs:    pub fn set_cloexec(&self) -> io::Result<()> {
    sys/unix/fd.rs:    pub fn set_cloexec(&self) -> io::Result<()> {
    sys/unix/fd.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys/unix/fd.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys/unix/fd.rs:    pub fn duplicate(&self) -> io::Result<FileDesc> {
    sys/sgx/net.rs:    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
    sys/sgx/net.rs:    pub fn connect_timeout(addr: &SocketAddr, dur: Duration) -> io::Result<TcpStream> {
    sys/sgx/net.rs:    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/sgx/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/sgx/net.rs:    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/sgx/net.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/sgx/net.rs:    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/sgx/net.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/sgx/net.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/sgx/net.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/sgx/net.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/sgx/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/sgx/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/sgx/net.rs:    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn duplicate(&self) -> io::Result<TcpStream> {
    sys/sgx/net.rs:    pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/sgx/net.rs:    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn nodelay(&self) -> io::Result<bool> {
    sys/sgx/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/sgx/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/sgx/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
    sys/sgx/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/sgx/net.rs:    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {
    sys/sgx/net.rs:    pub fn duplicate(&self) -> io::Result<TcpListener> {
    sys/sgx/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/sgx/net.rs:    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn only_v6(&self) -> io::Result<bool> {
    sys/sgx/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/sgx/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {
    sys/sgx/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/sgx/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/sgx/net.rs:    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/sgx/net.rs:    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/sgx/net.rs:    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {
    sys/sgx/net.rs:    pub fn duplicate(&self) -> io::Result<UdpSocket> {
    sys/sgx/net.rs:    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/sgx/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/sgx/net.rs:    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn broadcast(&self) -> io::Result<bool> {
    sys/sgx/net.rs:    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn multicast_loop_v4(&self) -> io::Result<bool> {
    sys/sgx/net.rs:    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {
    sys/sgx/net.rs:    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn multicast_loop_v6(&self) -> io::Result<bool> {
    sys/sgx/net.rs:    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/sgx/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/sgx/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/sgx/net.rs:    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/sgx/net.rs:    pub fn send(&self, _: &[u8]) -> io::Result<usize> {
    sys/sgx/net.rs:    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {
    sys/sgx/net.rs:    pub fn port(&self) -> u16 {
    sys/sgx/waitqueue/mod.rs:    pub fn queue_empty(&self) -> bool {
    sys/sgx/waitqueue/mod.rs:    pub fn lock_var(&self) -> &T {
    sys/sgx/waitqueue/mod.rs:    pub fn lock_var_mut(&mut self) -> &mut T {
    sys/sgx/waitqueue/mod.rs:    pub fn notified_tcs(&self) -> NotifiedTcs {
    sys/sgx/waitqueue/mod.rs:    pub fn drop_after<U>(self, guard: U) {
    sys/sgx/waitqueue/mod.rs:    pub fn is_empty(&self) -> bool {
    sys/sgx/waitqueue/mod.rs:    pub fn wait<T, F: FnOnce()>(mut guard: SpinMutexGuard<'_, WaitVariable<T>>, before_wait: F) {
    sys/sgx/waitqueue/mod.rs:    pub fn wait_timeout<T, F: FnOnce()>(
    sys/sgx/waitqueue/mod.rs:    pub fn notify_one<T>(
    sys/sgx/waitqueue/mod.rs:    pub fn notify_all<T>(
    sys/sgx/waitqueue/unsafe_list.rs:    pub fn new(value: T) -> Self {
    sys/sgx/waitqueue/unsafe_list.rs:    pub fn is_empty(&self) -> bool {
    sys/sgx/waitqueue/spin_mutex.rs:    pub fn lock(&self) -> SpinMutexGuard<'_, T> {
    sys/sgx/waitqueue/spin_mutex.rs:    pub fn try_lock(&self) -> Option<SpinMutexGuard<'_, T>> {
    sys/sgx/mod.rs:pub fn unsupported<T>() -> crate::io::Result<T> {
    sys/sgx/mod.rs:pub fn unsupported_err() -> crate::io::Error {
    sys/sgx/mod.rs:pub fn sgx_ineffective<T>(v: T) -> crate::io::Result<T> {
    sys/sgx/mod.rs:pub fn decode_error_kind(code: i32) -> ErrorKind {
    sys/sgx/mod.rs:pub fn abort_internal() -> ! {
    sys/sgx/mod.rs:    pub fn rdrand64() -> u64 {
    sys/sgx/mod.rs:pub fn hashmap_random_keys() -> (u64, u64) {
    sys/sgx/path.rs:pub fn is_sep_byte(b: u8) -> bool {
    sys/sgx/path.rs:pub fn is_verbatim_sep(b: u8) -> bool {
    sys/sgx/path.rs:pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {
    sys/sgx/os.rs:pub fn errno() -> i32 {
    sys/sgx/os.rs:pub fn error_string(errno: i32) -> String {
    sys/sgx/os.rs:pub fn getcwd() -> io::Result<PathBuf> {
    sys/sgx/os.rs:pub fn chdir(_: &path::Path) -> io::Result<()> {
    sys/sgx/os.rs:pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {
    sys/sgx/os.rs:pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>
    sys/sgx/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/sgx/os.rs:pub fn env() -> Env {
    sys/sgx/os.rs:pub fn getenv(k: &OsStr) -> Option<OsString> {
    sys/sgx/os.rs:pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {
    sys/sgx/os.rs:pub fn unsetenv(k: &OsStr) -> io::Result<()> {
    sys/sgx/os.rs:pub fn temp_dir() -> PathBuf {
    sys/sgx/os.rs:pub fn home_dir() -> Option<PathBuf> {
    sys/sgx/os.rs:pub fn exit(code: i32) -> ! {
    sys/sgx/os.rs:pub fn getpid() -> u32 {
    sys/sgx/stdio.rs:pub fn is_ebadf(err: &io::Error) -> bool {
    sys/sgx/stdio.rs:pub fn panic_output() -> Option<impl io::Write> {
    sys/sgx/args.rs:pub fn args() -> Args {
    sys/sgx/time.rs:    pub fn now() -> Instant {
    sys/sgx/time.rs:    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
    sys/sgx/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
    sys/sgx/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
    sys/sgx/time.rs:    pub fn now() -> SystemTime {
    sys/sgx/time.rs:    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {
    sys/sgx/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/sgx/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/sgx/thread.rs:        pub fn notify(self) {
    sys/sgx/thread.rs:        pub fn wait(self) {
    sys/sgx/thread.rs:    pub fn new() -> (Notifier, Waiter) {
    sys/sgx/thread.rs:    pub fn yield_now() {
    sys/sgx/thread.rs:    pub fn set_name(_name: &CStr) {
    sys/sgx/thread.rs:    pub fn sleep(dur: Duration) {
    sys/sgx/thread.rs:    pub fn join(self) {
    sys/sgx/thread.rs:pub fn available_parallelism() -> io::Result<NonZeroUsize> {
    sys/sgx/rwlock.rs:    pub fn read(&self) {
    sys/sgx/rwlock.rs:    pub fn write(&self) {
    sys/sgx/rwlock.rs:    pub fn try_write(&self) -> bool {
    sys/sgx/abi/reloc.rs:pub fn relocate_elf_rela() {
    sys/sgx/abi/mem.rs:pub fn image_base() -> u64 {
    sys/sgx/abi/mem.rs:pub fn is_enclave_range(p: *const u8, len: usize) -> bool {
    sys/sgx/abi/mem.rs:pub fn is_user_range(p: *const u8, len: usize) -> bool {
    sys/sgx/abi/thread.rs:pub fn current() -> Tcs {
    sys/sgx/abi/usercalls/mod.rs:pub fn read(fd: Fd, bufs: &mut [IoSliceMut<'_>]) -> IoResult<usize> {
    sys/sgx/abi/usercalls/mod.rs:pub fn read_alloc(fd: Fd) -> IoResult<Vec<u8>> {
    sys/sgx/abi/usercalls/mod.rs:pub fn write(fd: Fd, bufs: &[IoSlice<'_>]) -> IoResult<usize> {
    sys/sgx/abi/usercalls/mod.rs:pub fn flush(fd: Fd) -> IoResult<()> {
    sys/sgx/abi/usercalls/mod.rs:pub fn close(fd: Fd) {
    sys/sgx/abi/usercalls/mod.rs:pub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {
    sys/sgx/abi/usercalls/mod.rs:pub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {
    sys/sgx/abi/usercalls/mod.rs:pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {
    sys/sgx/abi/usercalls/mod.rs:pub fn exit(panic: bool) -> ! {
    sys/sgx/abi/usercalls/mod.rs:pub fn wait(event_mask: u64, mut timeout: u64) -> IoResult<u64> {
    sys/sgx/abi/usercalls/mod.rs:pub fn wait_timeout<F>(event_mask: u64, duration: Duration, should_wake_up: F)
    sys/sgx/abi/usercalls/mod.rs:pub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {
    sys/sgx/abi/usercalls/mod.rs:pub fn insecure_time() -> Duration {
    sys/sgx/abi/usercalls/mod.rs:pub fn alloc(size: usize, alignment: usize) -> IoResult<*mut u8> {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn new_from_enclave(val: &T) -> Self {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn into_raw(self) -> *mut T {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn uninitialized() -> Self {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn uninitialized(n: usize) -> Self {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn copy_from_enclave(&mut self, val: &T) {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn copy_to_enclave(&self, dest: &mut T) {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn as_raw_ptr(&self) -> *const T {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn as_raw_mut_ptr(&mut self) -> *mut T {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn to_enclave(&self) -> T {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn as_ptr(&self) -> *const T {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn as_mut_ptr(&mut self) -> *mut T {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn len(&self) -> usize {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn copy_to_enclave_vec(&self, dest: &mut Vec<T>) {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn to_enclave(&self) -> Vec<T> {
    sys/sgx/abi/usercalls/alloc.rs:    pub fn iter(&self) -> Iter<'_, T>
    sys/sgx/abi/usercalls/alloc.rs:    pub fn iter_mut(&mut self) -> IterMut<'_, T>
    sys/sgx/abi/usercalls/alloc.rs:    pub fn copy_user_buffer(&self) -> Vec<u8> {
    sys/sgx/abi/tls/mod.rs:    pub fn as_usize(self) -> usize {
    sys/sgx/abi/tls/mod.rs:    pub fn from_usize(index: usize) -> Self {
    sys/sgx/abi/tls/mod.rs:    pub fn new() -> Tls {
    sys/sgx/abi/tls/mod.rs:    pub fn create(dtor: Option<unsafe extern "C" fn(*mut u8)>) -> Key {
    sys/sgx/abi/tls/mod.rs:    pub fn set(key: Key, value: *mut u8) {
    sys/sgx/abi/tls/mod.rs:    pub fn get(key: Key) -> *mut u8 {
    sys/sgx/abi/tls/mod.rs:    pub fn destroy(key: Key) {
    sys/sgx/abi/tls/sync_bitset.rs:    pub fn get(&self, index: usize) -> bool {
    sys/sgx/abi/tls/sync_bitset.rs:    pub fn iter(&self) -> SyncBitsetIter<'_> {
    sys/sgx/abi/tls/sync_bitset.rs:    pub fn clear(&self, index: usize) {
    sys/sgx/abi/tls/sync_bitset.rs:    pub fn set(&self) -> Option<usize> {
    sys/sgx/fd.rs:    pub fn new(fd: Fd) -> FileDesc {
    sys/sgx/fd.rs:    pub fn raw(&self) -> Fd {
    sys/sgx/fd.rs:    pub fn into_raw(self) -> Fd {
    sys/sgx/fd.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/sgx/fd.rs:    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/sgx/fd.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/sgx/fd.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/sgx/fd.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/sgx/fd.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/sgx/fd.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/sgx/fd.rs:    pub fn flush(&self) -> io::Result<()> {
    sys/sgx/condvar.rs:    pub fn notify_one(&self) {
    sys/sgx/condvar.rs:    pub fn notify_all(&self) {
    sys/sgx/thread_parking.rs:pub fn park(_hint: usize) {
    sys/sgx/thread_parking.rs:pub fn park_timeout(dur: Duration, _hint: usize) {
    sys/sgx/thread_parking.rs:pub fn unpark(tid: ThreadId, _hint: usize) {
    sys/sgx/mutex.rs:    pub fn lock(&self) {
    sys/sgx/mutex.rs:    pub fn try_lock(&self) -> bool {
    sys/common/small_c_string.rs:pub fn run_path_with_cstr<T, F>(path: &Path, f: F) -> io::Result<T>
    sys/common/small_c_string.rs:pub fn run_with_cstr<T, F>(bytes: &[u8], f: F) -> io::Result<T>
    sys/solid/net.rs:pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {
    sys/solid/net.rs:pub fn cvt_gai(err: c_int) -> io::Result<()> {
    sys/solid/net.rs:pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>
    sys/solid/net.rs:pub fn init() {}
    sys/solid/net.rs:    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {
    sys/solid/net.rs:    pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {
    sys/solid/net.rs:    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {
    sys/solid/net.rs:    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {
    sys/solid/net.rs:    pub fn duplicate(&self) -> io::Result<Socket> {
    sys/solid/net.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/solid/net.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/solid/net.rs:    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/solid/net.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/solid/net.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/solid/net.rs:    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/solid/net.rs:    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/solid/net.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/solid/net.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/solid/net.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/solid/net.rs:    pub fn set_timeout(&self, dur: Option<Duration>, kind: c_int) -> io::Result<()> {
    sys/solid/net.rs:    pub fn timeout(&self, kind: c_int) -> io::Result<Option<Duration>> {
    sys/solid/net.rs:    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
    sys/solid/net.rs:    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {
    sys/solid/net.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/solid/net.rs:    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {
    sys/solid/net.rs:    pub fn nodelay(&self) -> io::Result<bool> {
    sys/solid/net.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys/solid/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/solid/net.rs:    pub fn as_raw(&self) -> c_int {
    sys/solid/error.rs:pub fn error_name(er: abi::ER) -> Option<&'static str> {
    sys/solid/error.rs:pub fn decode_error_kind(er: abi::ER) -> ErrorKind {
    sys/solid/mod.rs:pub fn unsupported<T>() -> crate::io::Result<T> {
    sys/solid/mod.rs:pub fn unsupported_err() -> crate::io::Error {
    sys/solid/mod.rs:pub fn decode_error_kind(code: i32) -> crate::io::ErrorKind {
    sys/solid/mod.rs:pub fn abort_internal() -> ! {
    sys/solid/mod.rs:pub fn hashmap_random_keys() -> (u64, u64) {
    sys/solid/path.rs:pub fn is_sep_byte(b: u8) -> bool {
    sys/solid/path.rs:pub fn is_verbatim_sep(b: u8) -> bool {
    sys/solid/path.rs:pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {
    sys/solid/os.rs:pub fn errno() -> i32 {
    sys/solid/os.rs:pub fn error_string(errno: i32) -> String {
    sys/solid/os.rs:pub fn getcwd() -> io::Result<PathBuf> {
    sys/solid/os.rs:pub fn chdir(_: &path::Path) -> io::Result<()> {
    sys/solid/os.rs:pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {
    sys/solid/os.rs:pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>
    sys/solid/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/solid/os.rs:pub fn env() -> Env {
    sys/solid/os.rs:pub fn getenv(k: &OsStr) -> Option<OsString> {
    sys/solid/os.rs:pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {
    sys/solid/os.rs:pub fn unsetenv(n: &OsStr) -> io::Result<()> {
    sys/solid/os.rs:pub fn temp_dir() -> PathBuf {
    sys/solid/os.rs:pub fn home_dir() -> Option<PathBuf> {
    sys/solid/os.rs:pub fn exit(code: i32) -> ! {
    sys/solid/os.rs:pub fn getpid() -> u32 {
    sys/solid/stdio.rs:pub fn is_ebadf(_err: &io::Error) -> bool {
    sys/solid/stdio.rs:pub fn panic_output() -> Option<impl io::Write> {
    sys/solid/memchr.rs:pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {
    sys/solid/memchr.rs:pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {
    sys/solid/time.rs:    pub fn now() -> SystemTime {
    sys/solid/time.rs:    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {
    sys/solid/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/solid/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/solid/io.rs:    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {
    sys/solid/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/solid/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/solid/io.rs:    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {
    sys/solid/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/solid/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/solid/io.rs:    pub fn as_mut_slice(&mut self) -> &mut [u8] {
    sys/solid/io.rs:pub fn is_terminal<T>(_: &T) -> bool {
    sys/solid/fs.rs:    pub fn size(&self) -> u64 {
    sys/solid/fs.rs:    pub fn perm(&self) -> FilePermissions {
    sys/solid/fs.rs:    pub fn file_type(&self) -> FileType {
    sys/solid/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/solid/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/solid/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/solid/fs.rs:    pub fn readonly(&self) -> bool {
    sys/solid/fs.rs:    pub fn set_readonly(&mut self, readonly: bool) {
    sys/solid/fs.rs:    pub fn set_accessed(&mut self, _t: SystemTime) {}
    sys/solid/fs.rs:    pub fn set_modified(&mut self, _t: SystemTime) {}
    sys/solid/fs.rs:    pub fn is_dir(&self) -> bool {
    sys/solid/fs.rs:    pub fn is_file(&self) -> bool {
    sys/solid/fs.rs:    pub fn is_symlink(&self) -> bool {
    sys/solid/fs.rs:    pub fn is(&self, mode: c_short) -> bool {
    sys/solid/fs.rs:pub fn readdir(p: &Path) -> io::Result<ReadDir> {
    sys/solid/fs.rs:    pub fn path(&self) -> PathBuf {
    sys/solid/fs.rs:    pub fn file_name(&self) -> OsString {
    sys/solid/fs.rs:    pub fn metadata(&self) -> io::Result<FileAttr> {
    sys/solid/fs.rs:    pub fn file_type(&self) -> io::Result<FileType> {
    sys/solid/fs.rs:    pub fn new() -> OpenOptions {
    sys/solid/fs.rs:    pub fn read(&mut self, read: bool) {
    sys/solid/fs.rs:    pub fn write(&mut self, write: bool) {
    sys/solid/fs.rs:    pub fn append(&mut self, append: bool) {
    sys/solid/fs.rs:    pub fn truncate(&mut self, truncate: bool) {
    sys/solid/fs.rs:    pub fn create(&mut self, create: bool) {
    sys/solid/fs.rs:    pub fn create_new(&mut self, create_new: bool) {
    sys/solid/fs.rs:    pub fn custom_flags(&mut self, flags: i32) {
    sys/solid/fs.rs:    pub fn mode(&mut self, _mode: u32) {}
    sys/solid/fs.rs:    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
    sys/solid/fs.rs:    pub fn file_attr(&self) -> io::Result<FileAttr> {
    sys/solid/fs.rs:    pub fn fsync(&self) -> io::Result<()> {
    sys/solid/fs.rs:    pub fn datasync(&self) -> io::Result<()> {
    sys/solid/fs.rs:    pub fn truncate(&self, _size: u64) -> io::Result<()> {
    sys/solid/fs.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/solid/fs.rs:    pub fn read_buf(&self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {
    sys/solid/fs.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/solid/fs.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/solid/fs.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/solid/fs.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/solid/fs.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/solid/fs.rs:    pub fn flush(&self) -> io::Result<()> {
    sys/solid/fs.rs:    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {
    sys/solid/fs.rs:    pub fn duplicate(&self) -> io::Result<File> {
    sys/solid/fs.rs:    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
    sys/solid/fs.rs:    pub fn set_times(&self, _times: FileTimes) -> io::Result<()> {
    sys/solid/fs.rs:    pub fn new() -> DirBuilder {
    sys/solid/fs.rs:    pub fn mkdir(&self, p: &Path) -> io::Result<()> {
    sys/solid/fs.rs:pub fn unlink(p: &Path) -> io::Result<()> {
    sys/solid/fs.rs:pub fn rename(old: &Path, new: &Path) -> io::Result<()> {
    sys/solid/fs.rs:pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {
    sys/solid/fs.rs:pub fn rmdir(p: &Path) -> io::Result<()> {
    sys/solid/fs.rs:pub fn remove_dir_all(path: &Path) -> io::Result<()> {
    sys/solid/fs.rs:pub fn readlink(p: &Path) -> io::Result<PathBuf> {
    sys/solid/fs.rs:pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {
    sys/solid/fs.rs:pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {
    sys/solid/fs.rs:pub fn stat(p: &Path) -> io::Result<FileAttr> {
    sys/solid/fs.rs:pub fn lstat(p: &Path) -> io::Result<FileAttr> {
    sys/solid/fs.rs:pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {
    sys/solid/fs.rs:pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {
    sys/solid/rwlock.rs:    pub fn read(&self) {
    sys/solid/rwlock.rs:    pub fn try_read(&self) -> bool {
    sys/solid/rwlock.rs:    pub fn write(&self) {
    sys/solid/rwlock.rs:    pub fn try_write(&self) -> bool {
    sys/solid/abi/mod.rs:    pub fn SOLID_RTC_ReadTime(time: *mut SOLID_RTC_TIME) -> c_int;
    sys/solid/abi/mod.rs:    pub fn SOLID_LOG_write(s: *const u8, l: usize);
    sys/solid/abi/mod.rs:    pub fn SOLID_TLS_AddDestructor(id: i32, dtor: unsafe extern "C" fn(*mut u8));
    sys/solid/abi/mod.rs:    pub fn SOLID_RNG_SampleRandomBytes(buffer: *mut u8, length: usize) -> c_int;
    sys/solid/abi/mod.rs:    pub fn rwl_loc_rdl(id: ID) -> ER;
    sys/solid/abi/mod.rs:    pub fn rwl_loc_wrl(id: ID) -> ER;
    sys/solid/abi/mod.rs:    pub fn rwl_ploc_rdl(id: ID) -> ER;
    sys/solid/abi/mod.rs:    pub fn rwl_ploc_wrl(id: ID) -> ER;
    sys/solid/abi/mod.rs:    pub fn rwl_unl_rwl(id: ID) -> ER;
    sys/solid/abi/mod.rs:    pub fn rwl_acre_rwl() -> ER_ID;
    sys/solid/abi/mod.rs:    pub fn rwl_del_rwl(id: ID) -> ER;
    sys/solid/abi/sockets.rs:    pub fn strerror(errnum: c_int) -> *const c_char;
    sys/solid/abi/sockets.rs:    pub fn SOLID_NET_GetLastError() -> c_int;
    sys/solid/abi/sockets.rs:    pub fn accept(s: c_int, addr: *mut sockaddr, addrlen: *mut socklen_t) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn bind(s: c_int, name: *const sockaddr, namelen: socklen_t) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn connect(s: c_int, name: *const sockaddr, namelen: socklen_t) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn close(s: c_int) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn dup(s: c_int) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn getpeername(s: c_int, name: *mut sockaddr, namelen: *mut socklen_t) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn getsockname(s: c_int, name: *mut sockaddr, namelen: *mut socklen_t) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn getsockopt(
    sys/solid/abi/sockets.rs:    pub fn setsockopt(
    sys/solid/abi/sockets.rs:    pub fn ioctl(s: c_int, cmd: c_long, argp: *mut c_void) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn listen(s: c_int, backlog: c_int) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn recv(s: c_int, mem: *mut c_void, len: size_t, flags: c_int) -> ssize_t;
    sys/solid/abi/sockets.rs:    pub fn read(s: c_int, mem: *mut c_void, len: size_t) -> ssize_t;
    sys/solid/abi/sockets.rs:    pub fn readv(s: c_int, bufs: *const iovec, bufcnt: c_int) -> ssize_t;
    sys/solid/abi/sockets.rs:    pub fn recvfrom(
    sys/solid/abi/sockets.rs:    pub fn send(s: c_int, mem: *const c_void, len: size_t, flags: c_int) -> ssize_t;
    sys/solid/abi/sockets.rs:    pub fn sendmsg(s: c_int, message: *const msghdr, flags: c_int) -> ssize_t;
    sys/solid/abi/sockets.rs:    pub fn sendto(
    sys/solid/abi/sockets.rs:    pub fn shutdown(s: c_int, how: c_int) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn socket(domain: c_int, type_: c_int, protocol: c_int) -> c_int;
    sys/solid/abi/sockets.rs:    pub fn write(s: c_int, mem: *const c_void, len: size_t) -> ssize_t;
    sys/solid/abi/sockets.rs:    pub fn writev(s: c_int, bufs: *const iovec, bufcnt: c_int) -> ssize_t;
    sys/solid/abi/sockets.rs:    pub fn freeaddrinfo(ai: *mut addrinfo);
    sys/solid/abi/sockets.rs:    pub fn getaddrinfo(
    sys/solid/abi/sockets.rs:    pub fn select(
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Open(fd: *mut c_int, path: *const c_char, mode: c_int) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Close(fd: c_int) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Read(fd: c_int, buf: *mut u8, size: usize, result: *mut usize) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Write(fd: c_int, buf: *const u8, size: usize, result: *mut usize) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Lseek(fd: c_int, offset: off_t, whence: c_int) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Sync(fd: c_int) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Ftell(fd: c_int, result: *mut off_t) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Feof(fd: c_int, result: *mut c_int) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Fsize(fd: c_int, result: *mut usize) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Truncate(path: *const c_char, size: off_t) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_OpenDir(path: *const c_char, pDir: *mut S_DIR) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_CloseDir(dir: S_DIR) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_ReadDir(dir: S_DIR, dirp: *mut dirent) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Stat(path: *const c_char, buf: *mut stat) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Unlink(path: *const c_char) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Rename(oldpath: *const c_char, newpath: *const c_char) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Chmod(path: *const c_char, mode: c_int) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Utime(path: *const c_char, time: time_t) -> c_int;
    sys/solid/abi/fs.rs:    pub fn SOLID_FS_Mkdir(path: *const c_char) -> c_int;
    sys/itron/spin.rs:    pub fn with_locked<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
    sys/itron/spin.rs:    pub fn get(&self) -> Option<(abi::ID, &T)> {
    sys/itron/spin.rs:    pub fn get_mut(&mut self) -> Option<(abi::ID, &mut T)> {
    sys/itron/spin.rs:    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<(abi::ID, &T), E>
    sys/itron/task.rs:pub fn current_task_id() -> abi::ID {
    sys/itron/task.rs:pub fn current_task_id_aborting() -> abi::ID {
    sys/itron/task.rs:pub fn try_current_task_id() -> Result<abi::ID, ItronError> {
    sys/itron/task.rs:pub fn task_priority(task: abi::ID) -> abi::PRI {
    sys/itron/task.rs:pub fn try_task_priority(task: abi::ID) -> Result<abi::PRI, ItronError> {
    sys/itron/error.rs:    pub fn new(er: abi::ER) -> Option<Self> {
    sys/itron/error.rs:    pub fn err_if_negative(er: abi::ER) -> Result<abi::ER, Self> {
    sys/itron/error.rs:    pub fn as_raw(&self) -> abi::ER {
    sys/itron/error.rs:pub fn error_name(er: abi::ER) -> Option<&'static str> {
    sys/itron/error.rs:pub fn decode_error_kind(er: abi::ER) -> ErrorKind {
    sys/itron/error.rs:pub fn expect_success(er: abi::ER, msg: &&str) -> abi::ER {
    sys/itron/error.rs:pub fn expect_success_aborting(er: abi::ER, msg: &&str) -> abi::ER {
    sys/itron/error.rs:pub fn fail(e: impl fmt::Display, msg: &&str) -> ! {
    sys/itron/error.rs:pub fn fail_aborting(e: impl fmt::Display, msg: &&str) -> ! {
    sys/itron/time.rs:    pub fn now() -> Instant {
    sys/itron/time.rs:    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
    sys/itron/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
    sys/itron/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
    sys/itron/time.rs:pub fn dur2reltims(dur: Duration) -> impl Iterator<Item = abi::RELTIM> {
    sys/itron/time.rs:pub fn with_tmos(dur: Duration, mut f: impl FnMut(abi::TMO) -> abi::ER) -> abi::ER {
    sys/itron/time.rs:pub fn with_tmos_strong(dur: Duration, mut f: impl FnMut(abi::TMO) -> abi::ER) -> abi::ER {
    sys/itron/abi.rs:    pub fn acre_tsk(pk_ctsk: *const T_CTSK) -> ER_ID;
    sys/itron/abi.rs:    pub fn get_tid(p_tskid: *mut ID) -> ER;
    sys/itron/abi.rs:    pub fn dly_tsk(dlytim: RELTIM) -> ER;
    sys/itron/abi.rs:    pub fn ter_tsk(tskid: ID) -> ER;
    sys/itron/abi.rs:    pub fn del_tsk(tskid: ID) -> ER;
    sys/itron/abi.rs:    pub fn get_pri(tskid: ID, p_tskpri: *mut PRI) -> ER;
    sys/itron/abi.rs:    pub fn rot_rdq(tskpri: PRI) -> ER;
    sys/itron/abi.rs:    pub fn slp_tsk() -> ER;
    sys/itron/abi.rs:    pub fn tslp_tsk(tmout: TMO) -> ER;
    sys/itron/abi.rs:    pub fn wup_tsk(tskid: ID) -> ER;
    sys/itron/abi.rs:    pub fn unl_cpu() -> ER;
    sys/itron/abi.rs:    pub fn dis_dsp() -> ER;
    sys/itron/abi.rs:    pub fn ena_dsp() -> ER;
    sys/itron/abi.rs:    pub fn sns_dsp() -> bool_t;
    sys/itron/abi.rs:    pub fn get_tim(p_systim: *mut SYSTIM) -> ER;
    sys/itron/abi.rs:    pub fn acre_flg(pk_cflg: *const T_CFLG) -> ER_ID;
    sys/itron/abi.rs:    pub fn del_flg(flgid: ID) -> ER;
    sys/itron/abi.rs:    pub fn set_flg(flgid: ID, setptn: FLGPTN) -> ER;
    sys/itron/abi.rs:    pub fn clr_flg(flgid: ID, clrptn: FLGPTN) -> ER;
    sys/itron/abi.rs:    pub fn wai_flg(flgid: ID, waiptn: FLGPTN, wfmode: MODE, p_flgptn: *mut FLGPTN) -> ER;
    sys/itron/abi.rs:    pub fn twai_flg(
    sys/itron/abi.rs:    pub fn acre_mtx(pk_cmtx: *const T_CMTX) -> ER_ID;
    sys/itron/abi.rs:    pub fn del_mtx(tskid: ID) -> ER;
    sys/itron/abi.rs:    pub fn loc_mtx(mtxid: ID) -> ER;
    sys/itron/abi.rs:    pub fn ploc_mtx(mtxid: ID) -> ER;
    sys/itron/abi.rs:    pub fn tloc_mtx(mtxid: ID, tmout: TMO) -> ER;
    sys/itron/abi.rs:    pub fn unl_mtx(mtxid: ID) -> ER;
    sys/itron/abi.rs:    pub fn exd_tsk() -> ER;
    sys/itron/thread.rs:    pub fn yield_now() {
    sys/itron/thread.rs:    pub fn set_name(_name: &CStr) {
    sys/itron/thread.rs:    pub fn sleep(dur: Duration) {
    sys/itron/thread.rs:    pub fn join(self) {
    sys/itron/thread.rs:pub fn available_parallelism() -> io::Result<crate::num::NonZeroUsize> {
    sys/itron/condvar.rs:    pub fn notify_one(&self) {
    sys/itron/condvar.rs:    pub fn notify_all(&self) {
    sys/itron/condvar.rs:        pub fn new() -> Self {
    sys/itron/condvar.rs:        pub fn pop_front(&mut self) -> Option<abi::ID> {
    sys/itron/thread_parking.rs:pub fn park(_hint: usize) {
    sys/itron/thread_parking.rs:pub fn park_timeout(dur: Duration, _hint: usize) {
    sys/itron/thread_parking.rs:pub fn unpark(id: ThreadId, _hint: usize) {
    sys/itron/mutex.rs:    pub fn lock(&self) {
    sys/itron/mutex.rs:    pub fn try_lock(&self) -> bool {
    sys/hermit/net.rs:pub fn cvt_gai(err: i32) -> io::Result<()> {
    sys/hermit/net.rs:pub fn init() {
    sys/hermit/net.rs:    pub fn new(addr: &SocketAddr, ty: i32) -> io::Result<Socket> {
    sys/hermit/net.rs:    pub fn new_raw(fam: i32, ty: i32) -> io::Result<Socket> {
    sys/hermit/net.rs:    pub fn new_pair(_fam: i32, _ty: i32) -> io::Result<(Socket, Socket)> {
    sys/hermit/net.rs:    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {
    sys/hermit/net.rs:    pub fn accept(
    sys/hermit/net.rs:    pub fn duplicate(&self) -> io::Result<Socket> {
    sys/hermit/net.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/hermit/net.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/hermit/net.rs:    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/hermit/net.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/hermit/net.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/hermit/net.rs:    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/hermit/net.rs:    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/hermit/net.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/hermit/net.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/hermit/net.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/hermit/net.rs:    pub fn set_timeout(&self, dur: Option<Duration>, kind: i32) -> io::Result<()> {
    sys/hermit/net.rs:    pub fn timeout(&self, kind: i32) -> io::Result<Option<Duration>> {
    sys/hermit/net.rs:    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
    sys/hermit/net.rs:    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {
    sys/hermit/net.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/hermit/net.rs:    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {
    sys/hermit/net.rs:    pub fn nodelay(&self) -> io::Result<bool> {
    sys/hermit/net.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys/hermit/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/hermit/net.rs:    pub fn as_raw(&self) -> RawFd {
    sys/hermit/futex.rs:pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {
    sys/hermit/futex.rs:pub fn futex_wake(futex: &AtomicU32) -> bool {
    sys/hermit/futex.rs:pub fn futex_wake_all(futex: &AtomicU32) {
    sys/hermit/mod.rs:pub fn unsupported<T>() -> crate::io::Result<T> {
    sys/hermit/mod.rs:pub fn unsupported_err() -> crate::io::Error {
    sys/hermit/mod.rs:pub fn abort_internal() -> ! {
    sys/hermit/mod.rs:pub fn hashmap_random_keys() -> (u64, u64) {
    sys/hermit/mod.rs:pub fn decode_error_kind(errno: i32) -> ErrorKind {
    sys/hermit/mod.rs:pub fn cvt<T: IsNegative>(t: T) -> crate::io::Result<T> {
    sys/hermit/mod.rs:pub fn cvt_r<T, F>(mut f: F) -> crate::io::Result<T>
    sys/hermit/os.rs:pub fn errno() -> i32 {
    sys/hermit/os.rs:pub fn error_string(_errno: i32) -> String {
    sys/hermit/os.rs:pub fn getcwd() -> io::Result<PathBuf> {
    sys/hermit/os.rs:pub fn chdir(_: &path::Path) -> io::Result<()> {
    sys/hermit/os.rs:pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {
    sys/hermit/os.rs:pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>
    sys/hermit/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/hermit/os.rs:pub fn init_environment(env: *const *const i8) {
    sys/hermit/os.rs:pub fn env() -> Env {
    sys/hermit/os.rs:pub fn getenv(k: &OsStr) -> Option<OsString> {
    sys/hermit/os.rs:pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {
    sys/hermit/os.rs:pub fn unsetenv(k: &OsStr) -> io::Result<()> {
    sys/hermit/os.rs:pub fn temp_dir() -> PathBuf {
    sys/hermit/os.rs:pub fn home_dir() -> Option<PathBuf> {
    sys/hermit/os.rs:pub fn exit(code: i32) -> ! {
    sys/hermit/os.rs:pub fn getpid() -> u32 {
    sys/hermit/stdio.rs:pub fn is_ebadf(_err: &io::Error) -> bool {
    sys/hermit/stdio.rs:pub fn panic_output() -> Option<impl io::Write> {
    sys/hermit/args.rs:pub fn args() -> Args {
    sys/hermit/time.rs:    pub fn now() -> Instant {
    sys/hermit/time.rs:    pub fn elapsed(&self) -> Duration {
    sys/hermit/time.rs:    pub fn duration_since(&self, earlier: Instant) -> Duration {
    sys/hermit/time.rs:    pub fn checked_duration_since(&self, earlier: Instant) -> Option<Duration> {
    sys/hermit/time.rs:    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
    sys/hermit/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
    sys/hermit/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
    sys/hermit/time.rs:    pub fn checked_add(&self, duration: Duration) -> Option<Instant> {
    sys/hermit/time.rs:    pub fn checked_sub(&self, duration: Duration) -> Option<Instant> {
    sys/hermit/time.rs:    pub fn now() -> SystemTime {
    sys/hermit/time.rs:    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {
    sys/hermit/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/hermit/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/hermit/thread.rs:    pub fn yield_now() {
    sys/hermit/thread.rs:    pub fn set_name(_name: &CStr) {
    sys/hermit/thread.rs:    pub fn sleep(dur: Duration) {
    sys/hermit/thread.rs:    pub fn join(self) {
    sys/hermit/thread.rs:    pub fn id(&self) -> Tid {
    sys/hermit/thread.rs:    pub fn into_id(self) -> Tid {
    sys/hermit/thread.rs:pub fn available_parallelism() -> io::Result<NonZeroUsize> {
    sys/hermit/fs.rs:    pub fn size(&self) -> u64 {
    sys/hermit/fs.rs:    pub fn perm(&self) -> FilePermissions {
    sys/hermit/fs.rs:    pub fn file_type(&self) -> FileType {
    sys/hermit/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/hermit/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/hermit/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/hermit/fs.rs:    pub fn readonly(&self) -> bool {
    sys/hermit/fs.rs:    pub fn set_readonly(&mut self, _readonly: bool) {
    sys/hermit/fs.rs:    pub fn set_accessed(&mut self, _t: SystemTime) {}
    sys/hermit/fs.rs:    pub fn set_modified(&mut self, _t: SystemTime) {}
    sys/hermit/fs.rs:    pub fn is_dir(&self) -> bool {
    sys/hermit/fs.rs:    pub fn is_file(&self) -> bool {
    sys/hermit/fs.rs:    pub fn is_symlink(&self) -> bool {
    sys/hermit/fs.rs:    pub fn path(&self) -> PathBuf {
    sys/hermit/fs.rs:    pub fn file_name(&self) -> OsString {
    sys/hermit/fs.rs:    pub fn metadata(&self) -> io::Result<FileAttr> {
    sys/hermit/fs.rs:    pub fn file_type(&self) -> io::Result<FileType> {
    sys/hermit/fs.rs:    pub fn new() -> OpenOptions {
    sys/hermit/fs.rs:    pub fn read(&mut self, read: bool) {
    sys/hermit/fs.rs:    pub fn write(&mut self, write: bool) {
    sys/hermit/fs.rs:    pub fn append(&mut self, append: bool) {
    sys/hermit/fs.rs:    pub fn truncate(&mut self, truncate: bool) {
    sys/hermit/fs.rs:    pub fn create(&mut self, create: bool) {
    sys/hermit/fs.rs:    pub fn create_new(&mut self, create_new: bool) {
    sys/hermit/fs.rs:    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
    sys/hermit/fs.rs:    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {
    sys/hermit/fs.rs:    pub fn file_attr(&self) -> io::Result<FileAttr> {
    sys/hermit/fs.rs:    pub fn fsync(&self) -> io::Result<()> {
    sys/hermit/fs.rs:    pub fn datasync(&self) -> io::Result<()> {
    sys/hermit/fs.rs:    pub fn truncate(&self, _size: u64) -> io::Result<()> {
    sys/hermit/fs.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/hermit/fs.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/hermit/fs.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/hermit/fs.rs:    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {
    sys/hermit/fs.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/hermit/fs.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/hermit/fs.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/hermit/fs.rs:    pub fn flush(&self) -> io::Result<()> {
    sys/hermit/fs.rs:    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {
    sys/hermit/fs.rs:    pub fn duplicate(&self) -> io::Result<File> {
    sys/hermit/fs.rs:    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
    sys/hermit/fs.rs:    pub fn set_times(&self, _times: FileTimes) -> io::Result<()> {
    sys/hermit/fs.rs:    pub fn new() -> DirBuilder {
    sys/hermit/fs.rs:    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {
    sys/hermit/fs.rs:pub fn readdir(_p: &Path) -> io::Result<ReadDir> {
    sys/hermit/fs.rs:pub fn unlink(path: &Path) -> io::Result<()> {
    sys/hermit/fs.rs:pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {
    sys/hermit/fs.rs:pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {
    sys/hermit/fs.rs:pub fn rmdir(_p: &Path) -> io::Result<()> {
    sys/hermit/fs.rs:pub fn remove_dir_all(_path: &Path) -> io::Result<()> {
    sys/hermit/fs.rs:pub fn readlink(_p: &Path) -> io::Result<PathBuf> {
    sys/hermit/fs.rs:pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {
    sys/hermit/fs.rs:pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {
    sys/hermit/fs.rs:pub fn stat(_p: &Path) -> io::Result<FileAttr> {
    sys/hermit/fs.rs:pub fn lstat(_p: &Path) -> io::Result<FileAttr> {
    sys/hermit/fs.rs:pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {
    sys/hermit/fd.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/hermit/fd.rs:    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {
    sys/hermit/fd.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/hermit/fd.rs:    pub fn duplicate(&self) -> io::Result<FileDesc> {
    sys/hermit/fd.rs:    pub fn duplicate_path(&self, _path: &[u8]) -> io::Result<FileDesc> {
    sys/hermit/fd.rs:    pub fn nonblocking(&self) -> io::Result<bool> {
    sys/hermit/fd.rs:    pub fn set_cloexec(&self) -> io::Result<()> {
    sys/hermit/fd.rs:    pub fn set_nonblocking(&self, _nonblocking: bool) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
    sys/unsupported/net.rs:    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {
    sys/unsupported/net.rs:    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/unsupported/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/unsupported/net.rs:    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unsupported/net.rs:    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unsupported/net.rs:    pub fn read_buf(&self, _buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unsupported/net.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/unsupported/net.rs:    pub fn write(&self, _: &[u8]) -> io::Result<usize> {
    sys/unsupported/net.rs:    pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unsupported/net.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/unsupported/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/unsupported/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/unsupported/net.rs:    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn duplicate(&self) -> io::Result<TcpStream> {
    sys/unsupported/net.rs:    pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/unsupported/net.rs:    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn nodelay(&self) -> io::Result<bool> {
    sys/unsupported/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/unsupported/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/unsupported/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
    sys/unsupported/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/unsupported/net.rs:    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {
    sys/unsupported/net.rs:    pub fn duplicate(&self) -> io::Result<TcpListener> {
    sys/unsupported/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/unsupported/net.rs:    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn only_v6(&self) -> io::Result<bool> {
    sys/unsupported/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/unsupported/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {
    sys/unsupported/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/unsupported/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/unsupported/net.rs:    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/unsupported/net.rs:    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/unsupported/net.rs:    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {
    sys/unsupported/net.rs:    pub fn duplicate(&self) -> io::Result<UdpSocket> {
    sys/unsupported/net.rs:    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/unsupported/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/unsupported/net.rs:    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn broadcast(&self) -> io::Result<bool> {
    sys/unsupported/net.rs:    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn multicast_loop_v4(&self) -> io::Result<bool> {
    sys/unsupported/net.rs:    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {
    sys/unsupported/net.rs:    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn multicast_loop_v6(&self) -> io::Result<bool> {
    sys/unsupported/net.rs:    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/unsupported/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/unsupported/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unsupported/net.rs:    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/unsupported/net.rs:    pub fn send(&self, _: &[u8]) -> io::Result<usize> {
    sys/unsupported/net.rs:    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {
    sys/unsupported/net.rs:    pub fn port(&self) -> u16 {
    sys/unsupported/common.rs:pub fn unsupported<T>() -> std_io::Result<T> {
    sys/unsupported/common.rs:pub fn unsupported_err() -> std_io::Error {
    sys/unsupported/common.rs:pub fn decode_error_kind(_code: i32) -> crate::io::ErrorKind {
    sys/unsupported/common.rs:pub fn abort_internal() -> ! {
    sys/unsupported/common.rs:pub fn hashmap_random_keys() -> (u64, u64) {
    sys/unsupported/locks/rwlock.rs:    pub fn read(&self) {
    sys/unsupported/locks/rwlock.rs:    pub fn try_read(&self) -> bool {
    sys/unsupported/locks/rwlock.rs:    pub fn write(&self) {
    sys/unsupported/locks/rwlock.rs:    pub fn try_write(&self) -> bool {
    sys/unsupported/locks/condvar.rs:    pub fn notify_one(&self) {}
    sys/unsupported/locks/condvar.rs:    pub fn notify_all(&self) {}
    sys/unsupported/locks/mutex.rs:    pub fn lock(&self) {
    sys/unsupported/locks/mutex.rs:    pub fn try_lock(&self) -> bool {
    sys/unsupported/os.rs:pub fn errno() -> i32 {
    sys/unsupported/os.rs:pub fn error_string(_errno: i32) -> String {
    sys/unsupported/os.rs:pub fn getcwd() -> io::Result<PathBuf> {
    sys/unsupported/os.rs:pub fn chdir(_: &path::Path) -> io::Result<()> {
    sys/unsupported/os.rs:pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {
    sys/unsupported/os.rs:pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>
    sys/unsupported/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/unsupported/os.rs:pub fn env() -> Env {
    sys/unsupported/os.rs:pub fn getenv(_: &OsStr) -> Option<OsString> {
    sys/unsupported/os.rs:pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {
    sys/unsupported/os.rs:pub fn unsetenv(_: &OsStr) -> io::Result<()> {
    sys/unsupported/os.rs:pub fn temp_dir() -> PathBuf {
    sys/unsupported/os.rs:pub fn home_dir() -> Option<PathBuf> {
    sys/unsupported/os.rs:pub fn exit(_code: i32) -> ! {
    sys/unsupported/os.rs:pub fn getpid() -> u32 {
    sys/unsupported/stdio.rs:pub fn is_ebadf(_err: &io::Error) -> bool {
    sys/unsupported/stdio.rs:pub fn panic_output() -> Option<Vec<u8>> {
    sys/unsupported/args.rs:pub fn args() -> Args {
    sys/unsupported/process.rs:    pub fn new(_program: &OsStr) -> Command {
    sys/unsupported/process.rs:    pub fn arg(&mut self, _arg: &OsStr) {}
    sys/unsupported/process.rs:    pub fn env_mut(&mut self) -> &mut CommandEnv {
    sys/unsupported/process.rs:    pub fn cwd(&mut self, _dir: &OsStr) {}
    sys/unsupported/process.rs:    pub fn stdin(&mut self, _stdin: Stdio) {}
    sys/unsupported/process.rs:    pub fn stdout(&mut self, _stdout: Stdio) {}
    sys/unsupported/process.rs:    pub fn stderr(&mut self, _stderr: Stdio) {}
    sys/unsupported/process.rs:    pub fn get_program(&self) -> &OsStr {
    sys/unsupported/process.rs:    pub fn get_args(&self) -> CommandArgs<'_> {
    sys/unsupported/process.rs:    pub fn get_envs(&self) -> CommandEnvs<'_> {
    sys/unsupported/process.rs:    pub fn get_current_dir(&self) -> Option<&Path> {
    sys/unsupported/process.rs:    pub fn spawn(
    sys/unsupported/process.rs:    pub fn output(&mut self) -> io::Result<(ExitStatus, Vec<u8>, Vec<u8>)> {
    sys/unsupported/process.rs:    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {
    sys/unsupported/process.rs:    pub fn code(&self) -> Option<i32> {
    sys/unsupported/process.rs:    pub fn code(self) -> Option<NonZeroI32> {
    sys/unsupported/process.rs:    pub fn as_i32(&self) -> i32 {
    sys/unsupported/process.rs:    pub fn id(&self) -> u32 {
    sys/unsupported/process.rs:    pub fn kill(&mut self) -> io::Result<()> {
    sys/unsupported/process.rs:    pub fn wait(&mut self) -> io::Result<ExitStatus> {
    sys/unsupported/process.rs:    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
    sys/unsupported/time.rs:    pub fn now() -> Instant {
    sys/unsupported/time.rs:    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
    sys/unsupported/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
    sys/unsupported/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
    sys/unsupported/time.rs:    pub fn now() -> SystemTime {
    sys/unsupported/time.rs:    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {
    sys/unsupported/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/unsupported/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/unsupported/thread.rs:    pub fn yield_now() {
    sys/unsupported/thread.rs:    pub fn set_name(_name: &CStr) {
    sys/unsupported/thread.rs:    pub fn sleep(_dur: Duration) {
    sys/unsupported/thread.rs:    pub fn join(self) {
    sys/unsupported/thread.rs:pub fn available_parallelism() -> io::Result<NonZeroUsize> {
    sys/unsupported/io.rs:    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {
    sys/unsupported/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/unsupported/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/unsupported/io.rs:    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {
    sys/unsupported/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/unsupported/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/unsupported/io.rs:    pub fn as_mut_slice(&mut self) -> &mut [u8] {
    sys/unsupported/io.rs:pub fn is_terminal<T>(_: &T) -> bool {
    sys/unsupported/fs.rs:    pub fn size(&self) -> u64 {
    sys/unsupported/fs.rs:    pub fn perm(&self) -> FilePermissions {
    sys/unsupported/fs.rs:    pub fn file_type(&self) -> FileType {
    sys/unsupported/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/unsupported/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/unsupported/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/unsupported/fs.rs:    pub fn readonly(&self) -> bool {
    sys/unsupported/fs.rs:    pub fn set_readonly(&mut self, _readonly: bool) {
    sys/unsupported/fs.rs:    pub fn set_accessed(&mut self, _t: SystemTime) {}
    sys/unsupported/fs.rs:    pub fn set_modified(&mut self, _t: SystemTime) {}
    sys/unsupported/fs.rs:    pub fn is_dir(&self) -> bool {
    sys/unsupported/fs.rs:    pub fn is_file(&self) -> bool {
    sys/unsupported/fs.rs:    pub fn is_symlink(&self) -> bool {
    sys/unsupported/fs.rs:    pub fn path(&self) -> PathBuf {
    sys/unsupported/fs.rs:    pub fn file_name(&self) -> OsString {
    sys/unsupported/fs.rs:    pub fn metadata(&self) -> io::Result<FileAttr> {
    sys/unsupported/fs.rs:    pub fn file_type(&self) -> io::Result<FileType> {
    sys/unsupported/fs.rs:    pub fn new() -> OpenOptions {
    sys/unsupported/fs.rs:    pub fn read(&mut self, _read: bool) {}
    sys/unsupported/fs.rs:    pub fn write(&mut self, _write: bool) {}
    sys/unsupported/fs.rs:    pub fn append(&mut self, _append: bool) {}
    sys/unsupported/fs.rs:    pub fn truncate(&mut self, _truncate: bool) {}
    sys/unsupported/fs.rs:    pub fn create(&mut self, _create: bool) {}
    sys/unsupported/fs.rs:    pub fn create_new(&mut self, _create_new: bool) {}
    sys/unsupported/fs.rs:    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {
    sys/unsupported/fs.rs:    pub fn file_attr(&self) -> io::Result<FileAttr> {
    sys/unsupported/fs.rs:    pub fn fsync(&self) -> io::Result<()> {
    sys/unsupported/fs.rs:    pub fn datasync(&self) -> io::Result<()> {
    sys/unsupported/fs.rs:    pub fn truncate(&self, _size: u64) -> io::Result<()> {
    sys/unsupported/fs.rs:    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {
    sys/unsupported/fs.rs:    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unsupported/fs.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/unsupported/fs.rs:    pub fn read_buf(&self, _cursor: BorrowedCursor<'_>) -> io::Result<()> {
    sys/unsupported/fs.rs:    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {
    sys/unsupported/fs.rs:    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unsupported/fs.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/unsupported/fs.rs:    pub fn flush(&self) -> io::Result<()> {
    sys/unsupported/fs.rs:    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {
    sys/unsupported/fs.rs:    pub fn duplicate(&self) -> io::Result<File> {
    sys/unsupported/fs.rs:    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
    sys/unsupported/fs.rs:    pub fn set_times(&self, _times: FileTimes) -> io::Result<()> {
    sys/unsupported/fs.rs:    pub fn new() -> DirBuilder {
    sys/unsupported/fs.rs:    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {
    sys/unsupported/fs.rs:pub fn readdir(_p: &Path) -> io::Result<ReadDir> {
    sys/unsupported/fs.rs:pub fn unlink(_p: &Path) -> io::Result<()> {
    sys/unsupported/fs.rs:pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {
    sys/unsupported/fs.rs:pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {
    sys/unsupported/fs.rs:pub fn rmdir(_p: &Path) -> io::Result<()> {
    sys/unsupported/fs.rs:pub fn remove_dir_all(_path: &Path) -> io::Result<()> {
    sys/unsupported/fs.rs:pub fn try_exists(_path: &Path) -> io::Result<bool> {
    sys/unsupported/fs.rs:pub fn readlink(_p: &Path) -> io::Result<PathBuf> {
    sys/unsupported/fs.rs:pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {
    sys/unsupported/fs.rs:pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {
    sys/unsupported/fs.rs:pub fn stat(_p: &Path) -> io::Result<FileAttr> {
    sys/unsupported/fs.rs:pub fn lstat(_p: &Path) -> io::Result<FileAttr> {
    sys/unsupported/fs.rs:pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {
    sys/unsupported/fs.rs:pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {
    sys/unsupported/pipe.rs:    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {
    sys/unsupported/pipe.rs:    pub fn read_buf(&self, _buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/unsupported/pipe.rs:    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/unsupported/pipe.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/unsupported/pipe.rs:    pub fn read_to_end(&self, _buf: &mut Vec<u8>) -> io::Result<usize> {
    sys/unsupported/pipe.rs:    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {
    sys/unsupported/pipe.rs:    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/unsupported/pipe.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/unsupported/pipe.rs:    pub fn diverge(&self) -> ! {
    sys/unsupported/pipe.rs:pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {
    sys/unsupported/once.rs:    pub fn is_completed(&self) -> bool {
    sys/unsupported/once.rs:    pub fn call(&self, ignore_poisoning: bool, f: &mut impl FnMut(&public::OnceState)) {
    sys/unsupported/once.rs:    pub fn is_poisoned(&self) -> bool {
    sys/unsupported/once.rs:    pub fn poison(&self) {
    sys/wasm/alloc.rs:    pub fn lock() -> DropLock {
    sys/wasm/alloc.rs:    pub fn lock() {} // no atomics, no threads, that's easy!
    sys/wasm/atomics/futex.rs:pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {
    sys/wasm/atomics/futex.rs:pub fn futex_wake(futex: &AtomicU32) -> bool {
    sys/wasm/atomics/futex.rs:pub fn futex_wake_all(futex: &AtomicU32) {
    sys/wasm/atomics/thread.rs:    pub fn yield_now() {}
    sys/wasm/atomics/thread.rs:    pub fn set_name(_name: &CStr) {}
    sys/wasm/atomics/thread.rs:    pub fn sleep(dur: Duration) {
    sys/wasm/atomics/thread.rs:    pub fn join(self) {}
    sys/wasm/atomics/thread.rs:pub fn available_parallelism() -> io::Result<NonZeroUsize> {
    sys/windows/c.rs:pub fn nt_success(status: NTSTATUS) -> bool {
    sys/windows/c.rs:    pub fn from_ref(slice: &[u16]) -> Self {
    sys/windows/c.rs:    pub fn status(&self) -> NTSTATUS {
    sys/windows/c.rs:        pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;
    sys/windows/c.rs:        pub fn OpenProcessToken(
    sys/windows/c.rs:        pub fn GetUserProfileDirectoryW(
    sys/windows/c.rs:        pub fn GetFileInformationByHandle(
    sys/windows/c.rs:        pub fn SetHandleInformation(hObject: HANDLE, dwMask: DWORD, dwFlags: DWORD) -> BOOL;
    sys/windows/c.rs:        pub fn AddVectoredExceptionHandler(
    sys/windows/c.rs:        pub fn CreateHardLinkW(
    sys/windows/c.rs:        pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;
    sys/windows/c.rs:        pub fn GetWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
    sys/windows/c.rs:    pub fn GetCurrentProcessId() -> DWORD;
    sys/windows/c.rs:    pub fn ReadConsoleW(
    sys/windows/c.rs:    pub fn WriteConsoleW(
    sys/windows/c.rs:    pub fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;
    sys/windows/c.rs:    pub fn GetSystemDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
    sys/windows/c.rs:    pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;
    sys/windows/c.rs:    pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;
    sys/windows/c.rs:    pub fn SetFileTime(
    sys/windows/c.rs:    pub fn SetLastError(dwErrCode: DWORD);
    sys/windows/c.rs:    pub fn GetCommandLineW() -> LPWSTR;
    sys/windows/c.rs:    pub fn GetTempPathW(nBufferLength: DWORD, lpBuffer: LPCWSTR) -> DWORD;
    sys/windows/c.rs:    pub fn GetCurrentProcess() -> HANDLE;
    sys/windows/c.rs:    pub fn GetCurrentThread() -> HANDLE;
    sys/windows/c.rs:    pub fn GetStdHandle(which: DWORD) -> HANDLE;
    sys/windows/c.rs:    pub fn ExitProcess(uExitCode: c_uint) -> !;
    sys/windows/c.rs:    pub fn DeviceIoControl(
    sys/windows/c.rs:    pub fn CreateThread(
    sys/windows/c.rs:    pub fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
    sys/windows/c.rs:    pub fn SwitchToThread() -> BOOL;
    sys/windows/c.rs:    pub fn Sleep(dwMilliseconds: DWORD);
    sys/windows/c.rs:    pub fn SleepEx(dwMilliseconds: DWORD, bAlertable: BOOL) -> DWORD;
    sys/windows/c.rs:    pub fn GetProcessId(handle: HANDLE) -> DWORD;
    sys/windows/c.rs:    pub fn CopyFileExW(
    sys/windows/c.rs:    pub fn FormatMessageW(
    sys/windows/c.rs:    pub fn TlsAlloc() -> DWORD;
    sys/windows/c.rs:    pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
    sys/windows/c.rs:    pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;
    sys/windows/c.rs:    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
    sys/windows/c.rs:    pub fn GetLastError() -> DWORD;
    sys/windows/c.rs:    pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;
    sys/windows/c.rs:    pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER) -> BOOL;
    sys/windows/c.rs:    pub fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;
    sys/windows/c.rs:    pub fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) -> BOOL;
    sys/windows/c.rs:    pub fn CreateProcessW(
    sys/windows/c.rs:    pub fn GetEnvironmentVariableW(n: LPCWSTR, v: LPWSTR, nsize: DWORD) -> DWORD;
    sys/windows/c.rs:    pub fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;
    sys/windows/c.rs:    pub fn GetEnvironmentStringsW() -> LPWCH;
    sys/windows/c.rs:    pub fn FreeEnvironmentStringsW(env_ptr: LPWCH) -> BOOL;
    sys/windows/c.rs:    pub fn GetModuleFileNameW(hModule: HMODULE, lpFilename: LPWSTR, nSize: DWORD) -> DWORD;
    sys/windows/c.rs:    pub fn CreateDirectoryW(
    sys/windows/c.rs:    pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;
    sys/windows/c.rs:    pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
    sys/windows/c.rs:    pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;
    sys/windows/c.rs:    pub fn DuplicateHandle(
    sys/windows/c.rs:    pub fn ReadFile(
    sys/windows/c.rs:    pub fn ReadFileEx(
    sys/windows/c.rs:    pub fn WriteFileEx(
    sys/windows/c.rs:    pub fn CloseHandle(hObject: HANDLE) -> BOOL;
    sys/windows/c.rs:    pub fn MoveFileExW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD)
    sys/windows/c.rs:    pub fn SetFilePointerEx(
    sys/windows/c.rs:    pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;
    sys/windows/c.rs:    pub fn CreateFileW(
    sys/windows/c.rs:    pub fn FindFirstFileW(fileName: LPCWSTR, findFileData: LPWIN32_FIND_DATAW) -> HANDLE;
    sys/windows/c.rs:    pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW) -> BOOL;
    sys/windows/c.rs:    pub fn FindClose(findFile: HANDLE) -> BOOL;
    sys/windows/c.rs:    pub fn GetProcAddress(handle: HMODULE, name: LPCSTR) -> *mut c_void;
    sys/windows/c.rs:    pub fn GetModuleHandleA(lpModuleName: LPCSTR) -> HMODULE;
    sys/windows/c.rs:    pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;
    sys/windows/c.rs:    pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);
    sys/windows/c.rs:    pub fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);
    sys/windows/c.rs:    pub fn CreateEventW(
    sys/windows/c.rs:    pub fn WaitForMultipleObjects(
    sys/windows/c.rs:    pub fn CreateNamedPipeW(
    sys/windows/c.rs:    pub fn CancelIo(handle: HANDLE) -> BOOL;
    sys/windows/c.rs:    pub fn GetOverlappedResult(
    sys/windows/c.rs:    pub fn CreateSymbolicLinkW(
    sys/windows/c.rs:    pub fn GetFinalPathNameByHandleW(
    sys/windows/c.rs:    pub fn GetFileInformationByHandleEx(
    sys/windows/c.rs:    pub fn SetFileInformationByHandle(
    sys/windows/c.rs:    pub fn GetFileType(hfile: HANDLE) -> DWORD;
    sys/windows/c.rs:    pub fn SleepConditionVariableSRW(
    sys/windows/c.rs:    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
    sys/windows/c.rs:    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
    sys/windows/c.rs:    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);
    sys/windows/c.rs:    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);
    sys/windows/c.rs:    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);
    sys/windows/c.rs:    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);
    sys/windows/c.rs:    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;
    sys/windows/c.rs:    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;
    sys/windows/c.rs:    pub fn InitOnceBeginInitialize(
    sys/windows/c.rs:    pub fn InitOnceComplete(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, lpContext: LPVOID) -> BOOL;
    sys/windows/c.rs:    pub fn CompareStringOrdinal(
    sys/windows/c.rs:    pub fn GetFullPathNameW(
    sys/windows/c.rs:    pub fn GetFileAttributesW(lpFileName: LPCWSTR) -> DWORD;
    sys/windows/c.rs:    pub fn MultiByteToWideChar(
    sys/windows/c.rs:    pub fn WideCharToMultiByte(
    sys/windows/c.rs:    pub fn WSAStartup(wVersionRequested: WORD, lpWSAData: LPWSADATA) -> c_int;
    sys/windows/c.rs:    pub fn WSACleanup() -> c_int;
    sys/windows/c.rs:    pub fn WSAGetLastError() -> c_int;
    sys/windows/c.rs:    pub fn WSADuplicateSocketW(
    sys/windows/c.rs:    pub fn WSASend(
    sys/windows/c.rs:    pub fn WSARecv(
    sys/windows/c.rs:    pub fn WSASocketW(
    sys/windows/c.rs:    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;
    sys/windows/c.rs:    pub fn closesocket(socket: SOCKET) -> c_int;
    sys/windows/c.rs:    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int, flags: c_int) -> c_int;
    sys/windows/c.rs:    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int, flags: c_int) -> c_int;
    sys/windows/c.rs:    pub fn recvfrom(
    sys/windows/c.rs:    pub fn sendto(
    sys/windows/c.rs:    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;
    sys/windows/c.rs:    pub fn accept(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> SOCKET;
    sys/windows/c.rs:    pub fn getsockopt(
    sys/windows/c.rs:    pub fn setsockopt(
    sys/windows/c.rs:    pub fn getsockname(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;
    sys/windows/c.rs:    pub fn getpeername(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;
    sys/windows/c.rs:    pub fn bind(socket: SOCKET, address: *const SOCKADDR, address_len: socklen_t) -> c_int;
    sys/windows/c.rs:    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;
    sys/windows/c.rs:    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int) -> c_int;
    sys/windows/c.rs:    pub fn getaddrinfo(
    sys/windows/c.rs:    pub fn freeaddrinfo(res: *mut ADDRINFOA);
    sys/windows/c.rs:    pub fn select(
    sys/windows/c.rs:    pub fn BCryptGenRandom(
    sys/windows/c.rs:    pub fn NtCreateFile(
    sys/windows/c.rs:    pub fn NtReadFile(
    sys/windows/c.rs:    pub fn NtWriteFile(
    sys/windows/c.rs:    pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;
    sys/windows/c.rs:    pub fn SetThreadDescription(hThread: HANDLE,
    sys/windows/c.rs:    pub fn GetSystemTimePreciseAsFileTime(lpSystemTimeAsFileTime: LPFILETIME)
    sys/windows/c.rs:    pub fn GetTempPath2W(nBufferLength: DWORD, lpBuffer: LPCWSTR) -> DWORD {
    sys/windows/c.rs:    pub fn WaitOnAddress(
    sys/windows/c.rs:    pub fn WakeByAddressSingle(Address: LPVOID);
    sys/windows/c.rs:    pub fn NtCreateKeyedEvent(
    sys/windows/c.rs:    pub fn NtReleaseKeyedEvent(
    sys/windows/c.rs:    pub fn NtWaitForKeyedEvent(
    sys/windows/stack_overflow_uwp.rs:    pub fn new() -> Handler {
    sys/windows/net.rs:pub fn init() {
    sys/windows/net.rs:pub fn cleanup() {
    sys/windows/net.rs:pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {
    sys/windows/net.rs:pub fn cvt_gai(err: c_int) -> io::Result<()> {
    sys/windows/net.rs:pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>
    sys/windows/net.rs:    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {
    sys/windows/net.rs:    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {
    sys/windows/net.rs:    pub fn accept(&self, storage: *mut c::SOCKADDR, len: *mut c_int) -> io::Result<Socket> {
    sys/windows/net.rs:    pub fn duplicate(&self) -> io::Result<Socket> {
    sys/windows/net.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/windows/net.rs:    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/windows/net.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/windows/net.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/windows/net.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/windows/net.rs:    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/windows/net.rs:    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/windows/net.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/windows/net.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/windows/net.rs:    pub fn set_timeout(&self, dur: Option<Duration>, kind: c_int) -> io::Result<()> {
    sys/windows/net.rs:    pub fn timeout(&self, kind: c_int) -> io::Result<Option<Duration>> {
    sys/windows/net.rs:    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
    sys/windows/net.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys/windows/net.rs:    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {
    sys/windows/net.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/windows/net.rs:    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {
    sys/windows/net.rs:    pub fn nodelay(&self) -> io::Result<bool> {
    sys/windows/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/windows/net.rs:    pub fn as_raw(&self) -> RawSocket {
    sys/windows/os_str.rs:    pub fn with_capacity(capacity: usize) -> Buf {
    sys/windows/os_str.rs:    pub fn clear(&mut self) {
    sys/windows/os_str.rs:    pub fn capacity(&self) -> usize {
    sys/windows/os_str.rs:    pub fn from_string(s: String) -> Buf {
    sys/windows/os_str.rs:    pub fn as_slice(&self) -> &Slice {
    sys/windows/os_str.rs:    pub fn as_mut_slice(&mut self) -> &mut Slice {
    sys/windows/os_str.rs:    pub fn into_string(self) -> Result<String, Buf> {
    sys/windows/os_str.rs:    pub fn push_slice(&mut self, s: &Slice) {
    sys/windows/os_str.rs:    pub fn reserve(&mut self, additional: usize) {
    sys/windows/os_str.rs:    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
    sys/windows/os_str.rs:    pub fn reserve_exact(&mut self, additional: usize) {
    sys/windows/os_str.rs:    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
    sys/windows/os_str.rs:    pub fn shrink_to_fit(&mut self) {
    sys/windows/os_str.rs:    pub fn shrink_to(&mut self, min_capacity: usize) {
    sys/windows/os_str.rs:    pub fn into_box(self) -> Box<Slice> {
    sys/windows/os_str.rs:    pub fn from_box(boxed: Box<Slice>) -> Buf {
    sys/windows/os_str.rs:    pub fn into_arc(&self) -> Arc<Slice> {
    sys/windows/os_str.rs:    pub fn into_rc(&self) -> Rc<Slice> {
    sys/windows/os_str.rs:    pub fn from_str(s: &str) -> &Slice {
    sys/windows/os_str.rs:    pub fn to_str(&self) -> Option<&str> {
    sys/windows/os_str.rs:    pub fn to_string_lossy(&self) -> Cow<'_, str> {
    sys/windows/os_str.rs:    pub fn to_owned(&self) -> Buf {
    sys/windows/os_str.rs:    pub fn clone_into(&self, buf: &mut Buf) {
    sys/windows/os_str.rs:    pub fn into_box(&self) -> Box<Slice> {
    sys/windows/os_str.rs:    pub fn empty_box() -> Box<Slice> {
    sys/windows/os_str.rs:    pub fn into_arc(&self) -> Arc<Slice> {
    sys/windows/os_str.rs:    pub fn into_rc(&self) -> Rc<Slice> {
    sys/windows/os_str.rs:    pub fn make_ascii_lowercase(&mut self) {
    sys/windows/os_str.rs:    pub fn make_ascii_uppercase(&mut self) {
    sys/windows/os_str.rs:    pub fn to_ascii_lowercase(&self) -> Buf {
    sys/windows/os_str.rs:    pub fn to_ascii_uppercase(&self) -> Buf {
    sys/windows/os_str.rs:    pub fn is_ascii(&self) -> bool {
    sys/windows/os_str.rs:    pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool {
    sys/windows/mod.rs:pub fn decode_error_kind(errno: i32) -> ErrorKind {
    sys/windows/mod.rs:pub fn unrolled_find_u16s(needle: u16, haystack: &[u16]) -> Option<usize> {
    sys/windows/mod.rs:pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> crate::io::Result<Vec<u16>> {
    sys/windows/mod.rs:pub fn truncate_utf16_at_nul(v: &[u16]) -> &[u16] {
    sys/windows/mod.rs:pub fn cvt<I: IsZero>(i: I) -> crate::io::Result<I> {
    sys/windows/mod.rs:pub fn dur2timeout(dur: Duration) -> c::DWORD {
    sys/windows/mod.rs:pub fn abort_internal() -> ! {
    sys/windows/path.rs:pub fn is_sep_byte(b: u8) -> bool {
    sys/windows/path.rs:pub fn is_verbatim_sep(b: u8) -> bool {
    sys/windows/path.rs:pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {
    sys/windows/locks/rwlock.rs:    pub fn read(&self) {
    sys/windows/locks/rwlock.rs:    pub fn try_read(&self) -> bool {
    sys/windows/locks/rwlock.rs:    pub fn write(&self) {
    sys/windows/locks/rwlock.rs:    pub fn try_write(&self) -> bool {
    sys/windows/locks/condvar.rs:    pub fn notify_one(&self) {
    sys/windows/locks/condvar.rs:    pub fn notify_all(&self) {
    sys/windows/locks/mutex.rs:    pub fn lock(&self) {
    sys/windows/locks/mutex.rs:    pub fn try_lock(&self) -> bool {
    sys/windows/os.rs:pub fn errno() -> i32 {
    sys/windows/os.rs:pub fn error_string(mut errnum: i32) -> String {
    sys/windows/os.rs:pub fn env() -> Env {
    sys/windows/os.rs:pub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {
    sys/windows/os.rs:pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
    sys/windows/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/windows/os.rs:pub fn getcwd() -> io::Result<PathBuf> {
    sys/windows/os.rs:pub fn chdir(p: &path::Path) -> io::Result<()> {
    sys/windows/os.rs:pub fn getenv(k: &OsStr) -> Option<OsString> {
    sys/windows/os.rs:pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {
    sys/windows/os.rs:pub fn unsetenv(n: &OsStr) -> io::Result<()> {
    sys/windows/os.rs:pub fn temp_dir() -> PathBuf {
    sys/windows/os.rs:pub fn home_dir() -> Option<PathBuf> {
    sys/windows/os.rs:pub fn exit(code: i32) -> ! {
    sys/windows/os.rs:pub fn getpid() -> u32 {
    sys/windows/stdio.rs:pub fn get_handle(handle_id: c::DWORD) -> io::Result<c::HANDLE> {
    sys/windows/stdio.rs:pub fn is_ebadf(err: &io::Error) -> bool {
    sys/windows/stdio.rs:pub fn panic_output() -> Option<impl io::Write> {
    sys/windows/compat.rs:    pub fn proc_address(self, name: &CStr) -> Option<NonNull<c_void>> {
    sys/windows/compat.rs:                pub fn option() -> Option<F> {
    sys/windows/cmath.rs:    pub fn acos(n: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn asin(n: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn atan(n: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn atan2(a: c_double, b: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn cbrt(n: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn cbrtf(n: c_float) -> c_float;
    sys/windows/cmath.rs:    pub fn cosh(n: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn expm1(n: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn expm1f(n: c_float) -> c_float;
    sys/windows/cmath.rs:    pub fn fdim(a: c_double, b: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn fdimf(a: c_float, b: c_float) -> c_float;
    sys/windows/cmath.rs:    pub fn hypot(x: c_double, y: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn hypotf(x: c_float, y: c_float) -> c_float;
    sys/windows/cmath.rs:    pub fn log1p(n: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn log1pf(n: c_float) -> c_float;
    sys/windows/cmath.rs:    pub fn sinh(n: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn tan(n: c_double) -> c_double;
    sys/windows/cmath.rs:    pub fn tanh(n: c_double) -> c_double;
    sys/windows/cmath.rs:        pub fn acosf(n: c_float) -> c_float;
    sys/windows/cmath.rs:        pub fn asinf(n: c_float) -> c_float;
    sys/windows/cmath.rs:        pub fn atan2f(a: c_float, b: c_float) -> c_float;
    sys/windows/cmath.rs:        pub fn atanf(n: c_float) -> c_float;
    sys/windows/cmath.rs:        pub fn coshf(n: c_float) -> c_float;
    sys/windows/cmath.rs:        pub fn sinhf(n: c_float) -> c_float;
    sys/windows/cmath.rs:        pub fn tanf(n: c_float) -> c_float;
    sys/windows/cmath.rs:        pub fn tanhf(n: c_float) -> c_float;
    sys/windows/handle.rs:    pub fn new_event(manual: bool, init: bool) -> io::Result<Handle> {
    sys/windows/handle.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/windows/handle.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/windows/handle.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/windows/handle.rs:    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {
    sys/windows/handle.rs:    pub fn read_buf(&self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {
    sys/windows/handle.rs:    pub fn overlapped_result(
    sys/windows/handle.rs:    pub fn cancel_io(&self) -> io::Result<()> {
    sys/windows/handle.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/windows/handle.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/windows/handle.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/windows/handle.rs:    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {
    sys/windows/handle.rs:    pub fn try_clone(&self) -> io::Result<Self> {
    sys/windows/handle.rs:    pub fn duplicate(
    sys/windows/args.rs:pub fn args() -> Args {
    sys/windows/process.rs:    pub fn new(program: &OsStr) -> Command {
    sys/windows/process.rs:    pub fn arg(&mut self, arg: &OsStr) {
    sys/windows/process.rs:    pub fn env_mut(&mut self) -> &mut CommandEnv {
    sys/windows/process.rs:    pub fn cwd(&mut self, dir: &OsStr) {
    sys/windows/process.rs:    pub fn stdin(&mut self, stdin: Stdio) {
    sys/windows/process.rs:    pub fn stdout(&mut self, stdout: Stdio) {
    sys/windows/process.rs:    pub fn stderr(&mut self, stderr: Stdio) {
    sys/windows/process.rs:    pub fn creation_flags(&mut self, flags: u32) {
    sys/windows/process.rs:    pub fn force_quotes(&mut self, enabled: bool) {
    sys/windows/process.rs:    pub fn raw_arg(&mut self, command_str_to_append: &OsStr) {
    sys/windows/process.rs:    pub fn get_program(&self) -> &OsStr {
    sys/windows/process.rs:    pub fn get_args(&self) -> CommandArgs<'_> {
    sys/windows/process.rs:    pub fn get_envs(&self) -> CommandEnvs<'_> {
    sys/windows/process.rs:    pub fn get_current_dir(&self) -> Option<&Path> {
    sys/windows/process.rs:    pub fn spawn(
    sys/windows/process.rs:    pub fn output(&mut self) -> io::Result<(ExitStatus, Vec<u8>, Vec<u8>)> {
    sys/windows/process.rs:    pub fn kill(&mut self) -> io::Result<()> {
    sys/windows/process.rs:    pub fn id(&self) -> u32 {
    sys/windows/process.rs:    pub fn main_thread_handle(&self) -> BorrowedHandle<'_> {
    sys/windows/process.rs:    pub fn wait(&mut self) -> io::Result<ExitStatus> {
    sys/windows/process.rs:    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
    sys/windows/process.rs:    pub fn handle(&self) -> &Handle {
    sys/windows/process.rs:    pub fn into_handle(self) -> Handle {
    sys/windows/process.rs:    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {
    sys/windows/process.rs:    pub fn code(&self) -> Option<i32> {
    sys/windows/process.rs:    pub fn code(self) -> Option<NonZeroI32> {
    sys/windows/process.rs:    pub fn as_i32(&self) -> i32 {
    sys/windows/time.rs:    pub fn now() -> Instant {
    sys/windows/time.rs:    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
    sys/windows/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
    sys/windows/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
    sys/windows/time.rs:    pub fn now() -> SystemTime {
    sys/windows/time.rs:    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {
    sys/windows/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/windows/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/windows/time.rs:        pub fn now() -> Self {
    sys/windows/time.rs:        pub fn epsilon() -> Duration {
    sys/windows/thread.rs:    pub fn set_name(name: &CStr) {
    sys/windows/thread.rs:    pub fn join(self) {
    sys/windows/thread.rs:    pub fn yield_now() {
    sys/windows/thread.rs:    pub fn sleep(dur: Duration) {
    sys/windows/thread.rs:    pub fn handle(&self) -> &Handle {
    sys/windows/thread.rs:    pub fn into_handle(self) -> Handle {
    sys/windows/thread.rs:pub fn available_parallelism() -> io::Result<NonZeroUsize> {
    sys/windows/rand.rs:pub fn hashmap_random_keys() -> (u64, u64) {
    sys/windows/io.rs:    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {
    sys/windows/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/windows/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/windows/io.rs:    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {
    sys/windows/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/windows/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/windows/io.rs:    pub fn as_mut_slice(&mut self) -> &mut [u8] {
    sys/windows/io.rs:pub fn is_terminal(h: &impl AsHandle) -> bool {
    sys/windows/fs.rs:    pub fn path(&self) -> PathBuf {
    sys/windows/fs.rs:    pub fn file_name(&self) -> OsString {
    sys/windows/fs.rs:    pub fn file_type(&self) -> io::Result<FileType> {
    sys/windows/fs.rs:    pub fn metadata(&self) -> io::Result<FileAttr> {
    sys/windows/fs.rs:    pub fn new() -> OpenOptions {
    sys/windows/fs.rs:    pub fn read(&mut self, read: bool) {
    sys/windows/fs.rs:    pub fn write(&mut self, write: bool) {
    sys/windows/fs.rs:    pub fn append(&mut self, append: bool) {
    sys/windows/fs.rs:    pub fn truncate(&mut self, truncate: bool) {
    sys/windows/fs.rs:    pub fn create(&mut self, create: bool) {
    sys/windows/fs.rs:    pub fn create_new(&mut self, create_new: bool) {
    sys/windows/fs.rs:    pub fn custom_flags(&mut self, flags: u32) {
    sys/windows/fs.rs:    pub fn access_mode(&mut self, access_mode: u32) {
    sys/windows/fs.rs:    pub fn share_mode(&mut self, share_mode: u32) {
    sys/windows/fs.rs:    pub fn attributes(&mut self, attrs: u32) {
    sys/windows/fs.rs:    pub fn security_qos_flags(&mut self, flags: u32) {
    sys/windows/fs.rs:    pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) {
    sys/windows/fs.rs:    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
    sys/windows/fs.rs:    pub fn fsync(&self) -> io::Result<()> {
    sys/windows/fs.rs:    pub fn datasync(&self) -> io::Result<()> {
    sys/windows/fs.rs:    pub fn truncate(&self, size: u64) -> io::Result<()> {
    sys/windows/fs.rs:    pub fn file_attr(&self) -> io::Result<FileAttr> {
    sys/windows/fs.rs:    pub fn file_attr(&self) -> io::Result<FileAttr> {
    sys/windows/fs.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/windows/fs.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/windows/fs.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/windows/fs.rs:    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {
    sys/windows/fs.rs:    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {
    sys/windows/fs.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/windows/fs.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/windows/fs.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/windows/fs.rs:    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {
    sys/windows/fs.rs:    pub fn flush(&self) -> io::Result<()> {
    sys/windows/fs.rs:    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {
    sys/windows/fs.rs:    pub fn duplicate(&self) -> io::Result<File> {
    sys/windows/fs.rs:    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {
    sys/windows/fs.rs:    pub fn set_times(&self, times: FileTimes) -> io::Result<()> {
    sys/windows/fs.rs:    pub fn size(&self) -> u64 {
    sys/windows/fs.rs:    pub fn perm(&self) -> FilePermissions {
    sys/windows/fs.rs:    pub fn attrs(&self) -> u32 {
    sys/windows/fs.rs:    pub fn file_type(&self) -> FileType {
    sys/windows/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/windows/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/windows/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/windows/fs.rs:    pub fn modified_u64(&self) -> u64 {
    sys/windows/fs.rs:    pub fn accessed_u64(&self) -> u64 {
    sys/windows/fs.rs:    pub fn created_u64(&self) -> u64 {
    sys/windows/fs.rs:    pub fn volume_serial_number(&self) -> Option<u32> {
    sys/windows/fs.rs:    pub fn number_of_links(&self) -> Option<u32> {
    sys/windows/fs.rs:    pub fn file_index(&self) -> Option<u64> {
    sys/windows/fs.rs:    pub fn readonly(&self) -> bool {
    sys/windows/fs.rs:    pub fn set_readonly(&mut self, readonly: bool) {
    sys/windows/fs.rs:    pub fn set_accessed(&mut self, t: SystemTime) {
    sys/windows/fs.rs:    pub fn set_modified(&mut self, t: SystemTime) {
    sys/windows/fs.rs:    pub fn is_dir(&self) -> bool {
    sys/windows/fs.rs:    pub fn is_file(&self) -> bool {
    sys/windows/fs.rs:    pub fn is_symlink(&self) -> bool {
    sys/windows/fs.rs:    pub fn is_symlink_dir(&self) -> bool {
    sys/windows/fs.rs:    pub fn is_symlink_file(&self) -> bool {
    sys/windows/fs.rs:    pub fn new() -> DirBuilder {
    sys/windows/fs.rs:    pub fn mkdir(&self, p: &Path) -> io::Result<()> {
    sys/windows/fs.rs:pub fn readdir(p: &Path) -> io::Result<ReadDir> {
    sys/windows/fs.rs:pub fn unlink(p: &Path) -> io::Result<()> {
    sys/windows/fs.rs:pub fn rename(old: &Path, new: &Path) -> io::Result<()> {
    sys/windows/fs.rs:pub fn rmdir(p: &Path) -> io::Result<()> {
    sys/windows/fs.rs:pub fn remove_dir_all(path: &Path) -> io::Result<()> {
    sys/windows/fs.rs:pub fn readlink(path: &Path) -> io::Result<PathBuf> {
    sys/windows/fs.rs:pub fn symlink(original: &Path, link: &Path) -> io::Result<()> {
    sys/windows/fs.rs:pub fn symlink_inner(original: &Path, link: &Path, dir: bool) -> io::Result<()> {
    sys/windows/fs.rs:pub fn link(original: &Path, link: &Path) -> io::Result<()> {
    sys/windows/fs.rs:pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {
    sys/windows/fs.rs:pub fn stat(path: &Path) -> io::Result<FileAttr> {
    sys/windows/fs.rs:pub fn lstat(path: &Path) -> io::Result<FileAttr> {
    sys/windows/fs.rs:pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {
    sys/windows/fs.rs:pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {
    sys/windows/fs.rs:pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {
    sys/windows/fs.rs:pub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(
    sys/windows/fs.rs:pub fn try_exists(path: &Path) -> io::Result<bool> {
    sys/windows/pipe.rs:pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Result<Pipes> {
    sys/windows/pipe.rs:pub fn spawn_pipe_relay(
    sys/windows/pipe.rs:    pub fn handle(&self) -> &Handle {
    sys/windows/pipe.rs:    pub fn into_handle(self) -> Handle {
    sys/windows/pipe.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys/windows/pipe.rs:    pub fn read_buf(&self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/windows/pipe.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/windows/pipe.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/windows/pipe.rs:    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {
    sys/windows/pipe.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys/windows/pipe.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/windows/pipe.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/windows/pipe.rs:pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {
    sys/windows/thread_parking.rs:    pub fn unpark(self: Pin<&Self>) {
    sys/freertos/net.rs:    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
    sys/freertos/net.rs:    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {
    sys/freertos/net.rs:    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/freertos/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/freertos/net.rs:    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/freertos/net.rs:    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/freertos/net.rs:    pub fn read_buf(&self, _buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/freertos/net.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/freertos/net.rs:    pub fn write(&self, _: &[u8]) -> io::Result<usize> {
    sys/freertos/net.rs:    pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/freertos/net.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/freertos/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/freertos/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/freertos/net.rs:    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn duplicate(&self) -> io::Result<TcpStream> {
    sys/freertos/net.rs:    pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys/freertos/net.rs:    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn nodelay(&self) -> io::Result<bool> {
    sys/freertos/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/freertos/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/freertos/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
    sys/freertos/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/freertos/net.rs:    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {
    sys/freertos/net.rs:    pub fn duplicate(&self) -> io::Result<TcpListener> {
    sys/freertos/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/freertos/net.rs:    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn only_v6(&self) -> io::Result<bool> {
    sys/freertos/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/freertos/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {
    sys/freertos/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys/freertos/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys/freertos/net.rs:    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/freertos/net.rs:    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys/freertos/net.rs:    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {
    sys/freertos/net.rs:    pub fn duplicate(&self) -> io::Result<UdpSocket> {
    sys/freertos/net.rs:    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys/freertos/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys/freertos/net.rs:    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn broadcast(&self) -> io::Result<bool> {
    sys/freertos/net.rs:    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn multicast_loop_v4(&self) -> io::Result<bool> {
    sys/freertos/net.rs:    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {
    sys/freertos/net.rs:    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn multicast_loop_v6(&self) -> io::Result<bool> {
    sys/freertos/net.rs:    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn set_ttl(&self, _: u32) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys/freertos/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys/freertos/net.rs:    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/freertos/net.rs:    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {
    sys/freertos/net.rs:    pub fn send(&self, _: &[u8]) -> io::Result<usize> {
    sys/freertos/net.rs:    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {
    sys/freertos/net.rs:    pub fn port(&self) -> u16 {
    sys/freertos/stdio/mod.rs:pub fn is_ebadf(_err: &io::Error) -> bool {
    sys/freertos/stdio/mod.rs:pub fn panic_output() -> Option<impl io::Write> {
    sys/freertos/common.rs:pub fn unsupported<T>() -> std_io::Result<T> {
    sys/freertos/common.rs:pub fn unsupported_err() -> std_io::Error {
    sys/freertos/common.rs:pub fn decode_error_kind(_code: i32) -> crate::io::ErrorKind {
    sys/freertos/common.rs:pub fn abort_internal() -> ! {
    sys/freertos/common.rs:pub fn hashmap_random_keys() -> (u64, u64) {
    sys/freertos/locks/rwlock.rs:    pub fn read(&self) {
    sys/freertos/locks/rwlock.rs:    pub fn try_read(&self) -> bool {
    sys/freertos/locks/rwlock.rs:    pub fn write(&self) {
    sys/freertos/locks/rwlock.rs:    pub fn try_write(&self) -> bool {
    sys/freertos/locks/condvar.rs:    pub fn notify_one(&self) {
    sys/freertos/locks/condvar.rs:    pub fn notify_all(&self) {
    sys/freertos/locks/mutex.rs:    pub fn lock(&self) {
    sys/freertos/locks/mutex.rs:    pub fn try_lock(&self) -> bool {
    sys/freertos/os.rs:pub fn errno() -> i32 {
    sys/freertos/os.rs:pub fn error_string(_errno: i32) -> String {
    sys/freertos/os.rs:pub fn getcwd() -> io::Result<PathBuf> {
    sys/freertos/os.rs:pub fn chdir(_: &path::Path) -> io::Result<()> {
    sys/freertos/os.rs:pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {
    sys/freertos/os.rs:pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>
    sys/freertos/os.rs:pub fn current_exe() -> io::Result<PathBuf> {
    sys/freertos/os.rs:pub fn env() -> Env {
    sys/freertos/os.rs:pub fn getenv(_: &OsStr) -> Option<OsString> {
    sys/freertos/os.rs:pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {
    sys/freertos/os.rs:pub fn unsetenv(_: &OsStr) -> io::Result<()> {
    sys/freertos/os.rs:pub fn temp_dir() -> PathBuf {
    sys/freertos/os.rs:pub fn home_dir() -> Option<PathBuf> {
    sys/freertos/os.rs:pub fn exit(_code: i32) -> ! {
    sys/freertos/os.rs:pub fn getpid() -> u32 {
    sys/freertos/args.rs:pub fn args() -> Args {
    sys/freertos/process.rs:    pub fn new(_program: &OsStr) -> Command {
    sys/freertos/process.rs:    pub fn arg(&mut self, _arg: &OsStr) {}
    sys/freertos/process.rs:    pub fn env_mut(&mut self) -> &mut CommandEnv {
    sys/freertos/process.rs:    pub fn cwd(&mut self, _dir: &OsStr) {}
    sys/freertos/process.rs:    pub fn stdin(&mut self, _stdin: Stdio) {}
    sys/freertos/process.rs:    pub fn stdout(&mut self, _stdout: Stdio) {}
    sys/freertos/process.rs:    pub fn stderr(&mut self, _stderr: Stdio) {}
    sys/freertos/process.rs:    pub fn get_program(&self) -> &OsStr {
    sys/freertos/process.rs:    pub fn get_args(&self) -> CommandArgs<'_> {
    sys/freertos/process.rs:    pub fn get_envs(&self) -> CommandEnvs<'_> {
    sys/freertos/process.rs:    pub fn get_current_dir(&self) -> Option<&Path> {
    sys/freertos/process.rs:    pub fn spawn(
    sys/freertos/process.rs:    pub fn output(&mut self) -> io::Result<(ExitStatus, Vec<u8>, Vec<u8>)> {
    sys/freertos/process.rs:    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {
    sys/freertos/process.rs:    pub fn code(&self) -> Option<i32> {
    sys/freertos/process.rs:    pub fn code(self) -> Option<NonZeroI32> {
    sys/freertos/process.rs:    pub fn as_i32(&self) -> i32 {
    sys/freertos/process.rs:    pub fn id(&self) -> u32 {
    sys/freertos/process.rs:    pub fn kill(&mut self) -> io::Result<()> {
    sys/freertos/process.rs:    pub fn wait(&mut self) -> io::Result<ExitStatus> {
    sys/freertos/process.rs:    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
    sys/freertos/time.rs:    pub fn now() -> Instant {
    sys/freertos/time.rs:    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {
    sys/freertos/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {
    sys/freertos/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {
    sys/freertos/time.rs:    pub fn now() -> SystemTime {
    sys/freertos/time.rs:    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {
    sys/freertos/time.rs:    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/freertos/time.rs:    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {
    sys/freertos/thread.rs:    pub fn yield_now() {
    sys/freertos/thread.rs:    pub fn set_name(_name: &CStr) {
    sys/freertos/thread.rs:    pub fn sleep(dur: Duration) {
    sys/freertos/thread.rs:    pub fn join(self) {
    sys/freertos/thread.rs:pub fn available_parallelism() -> io::Result<NonZeroUsize> {
    sys/freertos/io.rs:    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {
    sys/freertos/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/freertos/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/freertos/io.rs:    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {
    sys/freertos/io.rs:    pub fn advance(&mut self, n: usize) {
    sys/freertos/io.rs:    pub fn as_slice(&self) -> &[u8] {
    sys/freertos/io.rs:    pub fn as_mut_slice(&mut self) -> &mut [u8] {
    sys/freertos/io.rs:pub fn is_terminal<T>(_: &T) -> bool {
    sys/freertos/fs.rs:    pub fn size(&self) -> u64 {
    sys/freertos/fs.rs:    pub fn perm(&self) -> FilePermissions {
    sys/freertos/fs.rs:    pub fn file_type(&self) -> FileType {
    sys/freertos/fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
    sys/freertos/fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
    sys/freertos/fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
    sys/freertos/fs.rs:    pub fn readonly(&self) -> bool {
    sys/freertos/fs.rs:    pub fn set_readonly(&mut self, _readonly: bool) {
    sys/freertos/fs.rs:    pub fn set_accessed(&mut self, _t: SystemTime) {}
    sys/freertos/fs.rs:    pub fn set_modified(&mut self, _t: SystemTime) {}
    sys/freertos/fs.rs:    pub fn is_dir(&self) -> bool {
    sys/freertos/fs.rs:    pub fn is_file(&self) -> bool {
    sys/freertos/fs.rs:    pub fn is_symlink(&self) -> bool {
    sys/freertos/fs.rs:    pub fn path(&self) -> PathBuf {
    sys/freertos/fs.rs:    pub fn file_name(&self) -> OsString {
    sys/freertos/fs.rs:    pub fn metadata(&self) -> io::Result<FileAttr> {
    sys/freertos/fs.rs:    pub fn file_type(&self) -> io::Result<FileType> {
    sys/freertos/fs.rs:    pub fn new() -> OpenOptions {
    sys/freertos/fs.rs:    pub fn read(&mut self, _read: bool) {}
    sys/freertos/fs.rs:    pub fn write(&mut self, _write: bool) {}
    sys/freertos/fs.rs:    pub fn append(&mut self, _append: bool) {}
    sys/freertos/fs.rs:    pub fn truncate(&mut self, _truncate: bool) {}
    sys/freertos/fs.rs:    pub fn create(&mut self, _create: bool) {}
    sys/freertos/fs.rs:    pub fn create_new(&mut self, _create_new: bool) {}
    sys/freertos/fs.rs:    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {
    sys/freertos/fs.rs:    pub fn file_attr(&self) -> io::Result<FileAttr> {
    sys/freertos/fs.rs:    pub fn fsync(&self) -> io::Result<()> {
    sys/freertos/fs.rs:    pub fn datasync(&self) -> io::Result<()> {
    sys/freertos/fs.rs:    pub fn truncate(&self, _size: u64) -> io::Result<()> {
    sys/freertos/fs.rs:    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {
    sys/freertos/fs.rs:    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/freertos/fs.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/freertos/fs.rs:    pub fn read_buf(&self, _cursor: BorrowedCursor<'_>) -> io::Result<()> {
    sys/freertos/fs.rs:    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {
    sys/freertos/fs.rs:    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/freertos/fs.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/freertos/fs.rs:    pub fn flush(&self) -> io::Result<()> {
    sys/freertos/fs.rs:    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {
    sys/freertos/fs.rs:    pub fn duplicate(&self) -> io::Result<File> {
    sys/freertos/fs.rs:    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
    sys/freertos/fs.rs:    pub fn set_times(&self, _times: FileTimes) -> io::Result<()> {
    sys/freertos/fs.rs:    pub fn new() -> DirBuilder {
    sys/freertos/fs.rs:    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {
    sys/freertos/fs.rs:pub fn readdir(_p: &Path) -> io::Result<ReadDir> {
    sys/freertos/fs.rs:pub fn unlink(_p: &Path) -> io::Result<()> {
    sys/freertos/fs.rs:pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {
    sys/freertos/fs.rs:pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {
    sys/freertos/fs.rs:pub fn rmdir(_p: &Path) -> io::Result<()> {
    sys/freertos/fs.rs:pub fn remove_dir_all(_path: &Path) -> io::Result<()> {
    sys/freertos/fs.rs:pub fn try_exists(_path: &Path) -> io::Result<bool> {
    sys/freertos/fs.rs:pub fn readlink(_p: &Path) -> io::Result<PathBuf> {
    sys/freertos/fs.rs:pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {
    sys/freertos/fs.rs:pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {
    sys/freertos/fs.rs:pub fn stat(_p: &Path) -> io::Result<FileAttr> {
    sys/freertos/fs.rs:pub fn lstat(_p: &Path) -> io::Result<FileAttr> {
    sys/freertos/fs.rs:pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {
    sys/freertos/fs.rs:pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {
    sys/freertos/pipe.rs:    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {
    sys/freertos/pipe.rs:    pub fn read_buf(&self, _buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys/freertos/pipe.rs:    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys/freertos/pipe.rs:    pub fn is_read_vectored(&self) -> bool {
    sys/freertos/pipe.rs:    pub fn read_to_end(&self, _buf: &mut Vec<u8>) -> io::Result<usize> {
    sys/freertos/pipe.rs:    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {
    sys/freertos/pipe.rs:    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys/freertos/pipe.rs:    pub fn is_write_vectored(&self) -> bool {
    sys/freertos/pipe.rs:    pub fn diverge(&self) -> ! {
    sys/freertos/pipe.rs:pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {
    sys/freertos/freertos_api.rs:    pub fn vTaskDelay(xTicksToDelay : TickType_t);
    sys/freertos/freertos_api.rs:    pub fn uart_write ( buff : *const u8, buff_len : usize);
    sys/freertos/freertos_api.rs:    pub fn xTaskCreate (pxTaskCode : TaskFunction_t,
    sys/freertos/freertos_api.rs:    pub fn rust_std_xSemaphoreCreateMutex() -> SemaphoreHandle_t;
    sys/freertos/freertos_api.rs:    pub fn rust_std_xSemaphoreCreateBinary() -> SemaphoreHandle_t;
    sys/freertos/freertos_api.rs:    pub fn rust_std_xSemaphoreCreateCounting(
    sys/freertos/freertos_api.rs:    pub fn rust_std_xSemaphoreTake(xSemaphore : SemaphoreHandle_t, xTicksToWait : TickType_t) -> bool;
    sys/freertos/freertos_api.rs:    pub fn rust_std_xSemaphoreGive(xSemaphore : SemaphoreHandle_t);
    sys/freertos/freertos_api.rs:    pub fn rust_std_vSemaphoreDelete(xSemaphore : SemaphoreHandle_t);
    sys/freertos/freertos_api.rs:    pub fn rust_std_taskYIELD();
    sys/freertos/freertos_api.rs:    pub fn rust_std_msec_to_ticks(millis : u32) -> TickType_t;
    sys/freertos/freertos_api.rs:    pub fn rust_std_get_configNUM_THREAD_LOCAL_STORAGE_POINTERS () -> u32;
    sys/freertos/freertos_api.rs:    pub fn rust_std_vTaskSetThreadLocalStoragePointer(
    sys/freertos/freertos_api.rs:    pub fn rust_std_pvTaskGetThreadLocalStoragePointer(
    sys/freertos/freertos_api.rs:    pub fn rust_std_vTaskDelete( xTask : TaskHandle_t );
    sys/freertos/freertos_api.rs:    pub fn rust_std_xTaskGetTickCount( ) -> TickType_t;
    sys/freertos/freertos_api.rs:    pub fn rust_std_ticks_to_msec (ticks : TickType_t) -> u32;
    sys/freertos/freertos_api.rs:    pub fn rust_std_get_portBYTE_ALIGNMENT () -> usize;
    sys/freertos/freertos_api.rs:    pub fn rust_std_pvPortMalloc( xSize : u32 ) -> *mut u8 ;
    sys/freertos/freertos_api.rs:    pub fn rust_std_vPortFree( pv : *mut u8 );
    sys/freertos/once.rs:    pub fn is_completed(&self) -> bool {
    sys/freertos/once.rs:    pub fn call(&self, ignore_poisoning: bool, f: &mut impl FnMut(&public::OnceState)) {
    sys/freertos/once.rs:    pub fn is_poisoned(&self) -> bool {
    sys/freertos/once.rs:    pub fn poison(&self) {
    sys_common/net.rs:pub fn setsockopt<T>(
    sys_common/net.rs:pub fn getsockopt<T: Copy>(sock: &Socket, level: c_int, option_name: c_int) -> io::Result<T> {
    sys_common/net.rs:pub fn sockaddr_to_addr(storage: &c::sockaddr_storage, len: usize) -> io::Result<SocketAddr> {
    sys_common/net.rs:    pub fn port(&self) -> u16 {
    sys_common/net.rs:    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {
    sys_common/net.rs:    pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {
    sys_common/net.rs:    pub fn socket(&self) -> &Socket {
    sys_common/net.rs:    pub fn into_socket(self) -> Socket {
    sys_common/net.rs:    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
    sys_common/net.rs:    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
    sys_common/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys_common/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys_common/net.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys_common/net.rs:    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys_common/net.rs:    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {
    sys_common/net.rs:    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
    sys_common/net.rs:    pub fn is_read_vectored(&self) -> bool {
    sys_common/net.rs:    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {
    sys_common/net.rs:    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
    sys_common/net.rs:    pub fn is_write_vectored(&self) -> bool {
    sys_common/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys_common/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys_common/net.rs:    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
    sys_common/net.rs:    pub fn duplicate(&self) -> io::Result<TcpStream> {
    sys_common/net.rs:    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {
    sys_common/net.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
    sys_common/net.rs:    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {
    sys_common/net.rs:    pub fn nodelay(&self) -> io::Result<bool> {
    sys_common/net.rs:    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {
    sys_common/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys_common/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys_common/net.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys_common/net.rs:    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {
    sys_common/net.rs:    pub fn socket(&self) -> &Socket {
    sys_common/net.rs:    pub fn into_socket(self) -> Socket {
    sys_common/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys_common/net.rs:    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {
    sys_common/net.rs:    pub fn duplicate(&self) -> io::Result<TcpListener> {
    sys_common/net.rs:    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {
    sys_common/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys_common/net.rs:    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {
    sys_common/net.rs:    pub fn only_v6(&self) -> io::Result<bool> {
    sys_common/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys_common/net.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys_common/net.rs:    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {
    sys_common/net.rs:    pub fn socket(&self) -> &Socket {
    sys_common/net.rs:    pub fn into_socket(self) -> Socket {
    sys_common/net.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    sys_common/net.rs:    pub fn socket_addr(&self) -> io::Result<SocketAddr> {
    sys_common/net.rs:    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys_common/net.rs:    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    sys_common/net.rs:    pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {
    sys_common/net.rs:    pub fn duplicate(&self) -> io::Result<UdpSocket> {
    sys_common/net.rs:    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
    sys_common/net.rs:    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
    sys_common/net.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    sys_common/net.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    sys_common/net.rs:    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {
    sys_common/net.rs:    pub fn broadcast(&self) -> io::Result<bool> {
    sys_common/net.rs:    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {
    sys_common/net.rs:    pub fn multicast_loop_v4(&self) -> io::Result<bool> {
    sys_common/net.rs:    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {
    sys_common/net.rs:    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {
    sys_common/net.rs:    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {
    sys_common/net.rs:    pub fn multicast_loop_v6(&self) -> io::Result<bool> {
    sys_common/net.rs:    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {
    sys_common/net.rs:    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {
    sys_common/net.rs:    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {
    sys_common/net.rs:    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {
    sys_common/net.rs:    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {
    sys_common/net.rs:    pub fn ttl(&self) -> io::Result<u32> {
    sys_common/net.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    sys_common/net.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    sys_common/net.rs:    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys_common/net.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
    sys_common/net.rs:    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {
    sys_common/net.rs:    pub fn connect(&self, addr: io::Result<&SocketAddr>) -> io::Result<()> {
    sys_common/net.rs:    pub fn as_ptr(&self) -> *const c::sockaddr {
    sys_common/thread_parking/futex.rs:    pub fn unpark(self: Pin<&Self>) {
    sys_common/thread_parking/generic.rs:    pub fn unpark(self: Pin<&Self>) {
    sys_common/thread_parking/id.rs:    pub fn new() -> Parker {
    sys_common/thread_parking/id.rs:    pub fn unpark(self: Pin<&Self>) {
    sys_common/wtf8.rs:    pub fn from_u32(value: u32) -> Option<CodePoint> {
    sys_common/wtf8.rs:    pub fn from_char(value: char) -> CodePoint {
    sys_common/wtf8.rs:    pub fn to_u32(&self) -> u32 {
    sys_common/wtf8.rs:    pub fn to_lead_surrogate(&self) -> Option<u16> {
    sys_common/wtf8.rs:    pub fn to_trail_surrogate(&self) -> Option<u16> {
    sys_common/wtf8.rs:    pub fn to_char(&self) -> Option<char> {
    sys_common/wtf8.rs:    pub fn to_char_lossy(&self) -> char {
    sys_common/wtf8.rs:    pub fn new() -> Wtf8Buf {
    sys_common/wtf8.rs:    pub fn with_capacity(capacity: usize) -> Wtf8Buf {
    sys_common/wtf8.rs:    pub fn from_string(string: String) -> Wtf8Buf {
    sys_common/wtf8.rs:    pub fn from_str(str: &str) -> Wtf8Buf {
    sys_common/wtf8.rs:    pub fn clear(&mut self) {
    sys_common/wtf8.rs:    pub fn from_wide(v: &[u16]) -> Wtf8Buf {
    sys_common/wtf8.rs:    pub fn as_slice(&self) -> &Wtf8 {
    sys_common/wtf8.rs:    pub fn as_mut_slice(&mut self) -> &mut Wtf8 {
    sys_common/wtf8.rs:    pub fn reserve(&mut self, additional: usize) {
    sys_common/wtf8.rs:    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
    sys_common/wtf8.rs:    pub fn reserve_exact(&mut self, additional: usize) {
    sys_common/wtf8.rs:    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
    sys_common/wtf8.rs:    pub fn shrink_to_fit(&mut self) {
    sys_common/wtf8.rs:    pub fn shrink_to(&mut self, min_capacity: usize) {
    sys_common/wtf8.rs:    pub fn capacity(&self) -> usize {
    sys_common/wtf8.rs:    pub fn push_str(&mut self, other: &str) {
    sys_common/wtf8.rs:    pub fn push_wtf8(&mut self, other: &Wtf8) {
    sys_common/wtf8.rs:    pub fn push_char(&mut self, c: char) {
    sys_common/wtf8.rs:    pub fn push(&mut self, code_point: CodePoint) {
    sys_common/wtf8.rs:    pub fn truncate(&mut self, new_len: usize) {
    sys_common/wtf8.rs:    pub fn into_string(self) -> Result<String, Wtf8Buf> {
    sys_common/wtf8.rs:    pub fn into_string_lossy(mut self) -> String {
    sys_common/wtf8.rs:    pub fn into_box(self) -> Box<Wtf8> {
    sys_common/wtf8.rs:    pub fn from_box(boxed: Box<Wtf8>) -> Wtf8Buf {
    sys_common/wtf8.rs:    pub fn from_str(value: &str) -> &Wtf8 {
    sys_common/wtf8.rs:    pub fn len(&self) -> usize {
    sys_common/wtf8.rs:    pub fn is_empty(&self) -> bool {
    sys_common/wtf8.rs:    pub fn ascii_byte_at(&self, position: usize) -> u8 {
    sys_common/wtf8.rs:    pub fn code_points(&self) -> Wtf8CodePoints<'_> {
    sys_common/wtf8.rs:    pub fn as_str(&self) -> Option<&str> {
    sys_common/wtf8.rs:    pub fn to_owned(&self) -> Wtf8Buf {
    sys_common/wtf8.rs:    pub fn to_string_lossy(&self) -> Cow<'_, str> {
    sys_common/wtf8.rs:    pub fn encode_wide(&self) -> EncodeWide<'_> {
    sys_common/wtf8.rs:    pub fn clone_into(&self, buf: &mut Wtf8Buf) {
    sys_common/wtf8.rs:    pub fn into_box(&self) -> Box<Wtf8> {
    sys_common/wtf8.rs:    pub fn empty_box() -> Box<Wtf8> {
    sys_common/wtf8.rs:    pub fn into_arc(&self) -> Arc<Wtf8> {
    sys_common/wtf8.rs:    pub fn into_rc(&self) -> Rc<Wtf8> {
    sys_common/wtf8.rs:    pub fn make_ascii_lowercase(&mut self) {
    sys_common/wtf8.rs:    pub fn make_ascii_uppercase(&mut self) {
    sys_common/wtf8.rs:    pub fn to_ascii_lowercase(&self) -> Wtf8Buf {
    sys_common/wtf8.rs:    pub fn to_ascii_uppercase(&self) -> Wtf8Buf {
    sys_common/wtf8.rs:    pub fn is_ascii(&self) -> bool {
    sys_common/wtf8.rs:    pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool {
    sys_common/wtf8.rs:pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool {
    sys_common/wtf8.rs:pub fn slice_error_fail(s: &Wtf8, begin: usize, end: usize) -> ! {
    sys_common/thread_info.rs:pub fn current_thread() -> Option<Thread> {
    sys_common/thread_info.rs:pub fn stack_guard() -> Option<Guard> {
    sys_common/thread_info.rs:pub fn set(stack_guard: Option<Guard>, thread: Thread) {
    sys_common/mod.rs:pub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 {
    sys_common/thread_local_key.rs:    pub fn new(dtor: Option<unsafe extern "C" fn(*mut u8)>) -> Key {
    sys_common/thread_local_key.rs:    pub fn get(&self) -> *mut u8 {
    sys_common/thread_local_key.rs:    pub fn set(&self, val: *mut u8) {
    sys_common/process.rs:    pub fn capture(&self) -> BTreeMap<EnvKey, OsString> {
    sys_common/process.rs:    pub fn is_unchanged(&self) -> bool {
    sys_common/process.rs:    pub fn capture_if_changed(&self) -> Option<BTreeMap<EnvKey, OsString>> {
    sys_common/process.rs:    pub fn set(&mut self, key: &OsStr, value: &OsStr) {
    sys_common/process.rs:    pub fn remove(&mut self, key: &OsStr) {
    sys_common/process.rs:    pub fn clear(&mut self) {
    sys_common/process.rs:    pub fn have_changed_path(&self) -> bool {
    sys_common/process.rs:    pub fn iter(&self) -> CommandEnvs<'_> {
    sys_common/process.rs:pub fn wait_with_output(
    sys_common/memchr.rs:pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {
    sys_common/memchr.rs:pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {
    sys_common/thread.rs:pub fn min_stack() -> usize {
    sys_common/once/futex.rs:    pub fn is_poisoned(&self) -> bool {
    sys_common/once/futex.rs:    pub fn poison(&self) {
    sys_common/once/futex.rs:    pub fn is_completed(&self) -> bool {
    sys_common/once/futex.rs:    pub fn call(&self, ignore_poisoning: bool, f: &mut impl FnMut(&public::OnceState)) {
    sys_common/once/queue.rs:    pub fn is_completed(&self) -> bool {
    sys_common/once/queue.rs:    pub fn call(&self, ignore_poisoning: bool, init: &mut dyn FnMut(&public::OnceState)) {
    sys_common/once/queue.rs:    pub fn is_poisoned(&self) -> bool {
    sys_common/once/queue.rs:    pub fn poison(&self) {
    sys_common/backtrace.rs:pub fn lock() -> impl Drop {
    sys_common/backtrace.rs:pub fn print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {
    sys_common/backtrace.rs:pub fn __rust_begin_short_backtrace<F, T>(f: F) -> T
    sys_common/backtrace.rs:pub fn __rust_end_short_backtrace<F, T>(f: F) -> T
    sys_common/backtrace.rs:pub fn output_filename(
    sys_common/io.rs:        pub fn join(&self, path: &str) -> PathBuf {
    sys_common/io.rs:        pub fn path(&self) -> &Path {
    sys_common/io.rs:    pub fn tmpdir() -> TempDir {
    sys_common/fs.rs:pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {
    sys_common/fs.rs:pub fn remove_dir_all(path: &Path) -> io::Result<()> {
    sys_common/fs.rs:pub fn try_exists(path: &Path) -> io::Result<bool> {
    sys_common/wstr.rs:    pub fn peek(&self) -> Option<NonZeroU16> {
    sys_common/wstr.rs:    pub fn advance_while<P: FnMut(NonZeroU16) -> bool>(&mut self, mut predicate: P) -> usize {

OS:
    os/wasi/fs.rs:pub fn link<P: AsRef<Path>, U: AsRef<Path>>(
    os/wasi/fs.rs:pub fn rename<P: AsRef<Path>, U: AsRef<Path>>(
    os/wasi/fs.rs:pub fn symlink<P: AsRef<Path>, U: AsRef<Path>>(
    os/wasi/fs.rs:pub fn symlink_path<P: AsRef<Path>, U: AsRef<Path>>(old_path: P, new_path: U) -> io::Result<()> {
    os/unix/net/addr.rs:    pub fn from_pathname<P>(path: P) -> io::Result<SocketAddr>
    os/unix/net/addr.rs:    pub fn is_unnamed(&self) -> bool {
    os/unix/net/addr.rs:    pub fn as_pathname(&self) -> Option<&Path> {
    os/unix/net/datagram.rs:    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {
    os/unix/net/datagram.rs:    pub fn bind_addr(socket_addr: &SocketAddr) -> io::Result<UnixDatagram> {
    os/unix/net/datagram.rs:    pub fn unbound() -> io::Result<UnixDatagram> {
    os/unix/net/datagram.rs:    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {
    os/unix/net/datagram.rs:    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
    os/unix/net/datagram.rs:    pub fn connect_addr(&self, socket_addr: &SocketAddr) -> io::Result<()> {
    os/unix/net/datagram.rs:    pub fn try_clone(&self) -> io::Result<UnixDatagram> {
    os/unix/net/datagram.rs:    pub fn local_addr(&self) -> io::Result<SocketAddr> {
    os/unix/net/datagram.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    os/unix/net/datagram.rs:    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    os/unix/net/datagram.rs:    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {
    os/unix/net/datagram.rs:    pub fn recv_vectored_with_ancillary_from(
    os/unix/net/datagram.rs:    pub fn recv_vectored_with_ancillary(
    os/unix/net/datagram.rs:    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {
    os/unix/net/datagram.rs:    pub fn send_to_addr(&self, buf: &[u8], socket_addr: &SocketAddr) -> io::Result<usize> {
    os/unix/net/datagram.rs:    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {
    os/unix/net/datagram.rs:    pub fn send_vectored_with_ancillary_to<P: AsRef<Path>>(
    os/unix/net/datagram.rs:    pub fn send_vectored_with_ancillary(
    os/unix/net/datagram.rs:    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
    os/unix/net/datagram.rs:    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
    os/unix/net/datagram.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    os/unix/net/datagram.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    os/unix/net/datagram.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    os/unix/net/datagram.rs:    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {
    os/unix/net/datagram.rs:    pub fn passcred(&self) -> io::Result<bool> {
    os/unix/net/datagram.rs:    pub fn set_mark(&self, mark: u32) -> io::Result<()> {
    os/unix/net/datagram.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    os/unix/net/datagram.rs:    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
    os/unix/net/datagram.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
    os/unix/net/datagram.rs:    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
    os/unix/net/stream.rs:    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {
    os/unix/net/stream.rs:    pub fn connect_addr(socket_addr: &SocketAddr) -> io::Result<UnixStream> {
    os/unix/net/stream.rs:    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {
    os/unix/net/stream.rs:    pub fn try_clone(&self) -> io::Result<UnixStream> {
    os/unix/net/stream.rs:    pub fn local_addr(&self) -> io::Result<SocketAddr> {
    os/unix/net/stream.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
    os/unix/net/stream.rs:    pub fn peer_cred(&self) -> io::Result<UCred> {
    os/unix/net/stream.rs:    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
    os/unix/net/stream.rs:    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {
    os/unix/net/stream.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
    os/unix/net/stream.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
    os/unix/net/stream.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    os/unix/net/stream.rs:    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {
    os/unix/net/stream.rs:    pub fn passcred(&self) -> io::Result<bool> {
    os/unix/net/stream.rs:    pub fn set_mark(&self, mark: u32) -> io::Result<()> {
    os/unix/net/stream.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    os/unix/net/stream.rs:    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
    os/unix/net/stream.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
    os/unix/net/stream.rs:    pub fn recv_vectored_with_ancillary(
    os/unix/net/stream.rs:    pub fn send_vectored_with_ancillary(
    os/unix/net/listener.rs:    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {
    os/unix/net/listener.rs:    pub fn bind_addr(socket_addr: &SocketAddr) -> io::Result<UnixListener> {
    os/unix/net/listener.rs:    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {
    os/unix/net/listener.rs:    pub fn try_clone(&self) -> io::Result<UnixListener> {
    os/unix/net/listener.rs:    pub fn local_addr(&self) -> io::Result<SocketAddr> {
    os/unix/net/listener.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
    os/unix/net/listener.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
    os/unix/net/listener.rs:    pub fn incoming(&self) -> Incoming<'_> {
    os/unix/net/ancillary.rs:    pub fn new() -> SocketCred {
    os/unix/net/ancillary.rs:    pub fn set_pid(&mut self, pid: libc::pid_t) {
    os/unix/net/ancillary.rs:    pub fn get_pid(&self) -> libc::pid_t {
    os/unix/net/ancillary.rs:    pub fn set_uid(&mut self, uid: libc::uid_t) {
    os/unix/net/ancillary.rs:    pub fn get_uid(&self) -> libc::uid_t {
    os/unix/net/ancillary.rs:    pub fn set_gid(&mut self, gid: libc::gid_t) {
    os/unix/net/ancillary.rs:    pub fn get_gid(&self) -> libc::gid_t {
    os/unix/net/ancillary.rs:    pub fn new() -> SocketCred {
    os/unix/net/ancillary.rs:    pub fn set_pid(&mut self, pid: libc::pid_t) {
    os/unix/net/ancillary.rs:    pub fn get_pid(&self) -> libc::pid_t {
    os/unix/net/ancillary.rs:    pub fn set_uid(&mut self, uid: libc::uid_t) {
    os/unix/net/ancillary.rs:    pub fn get_uid(&self) -> libc::uid_t {
    os/unix/net/ancillary.rs:    pub fn set_gid(&mut self, gid: libc::gid_t) {
    os/unix/net/ancillary.rs:    pub fn get_gid(&self) -> libc::gid_t {
    os/unix/net/ancillary.rs:    pub fn new() -> SocketCred {
    os/unix/net/ancillary.rs:    pub fn set_pid(&mut self, pid: libc::pid_t) {
    os/unix/net/ancillary.rs:    pub fn get_pid(&self) -> libc::pid_t {
    os/unix/net/ancillary.rs:    pub fn set_uid(&mut self, uid: libc::uid_t) {
    os/unix/net/ancillary.rs:    pub fn get_uid(&self) -> libc::uid_t {
    os/unix/net/ancillary.rs:    pub fn set_gid(&mut self, gid: libc::gid_t) {
    os/unix/net/ancillary.rs:    pub fn get_gid(&self) -> libc::gid_t {
    os/unix/net/ancillary.rs:    pub fn new(buffer: &'a mut [u8]) -> Self {
    os/unix/net/ancillary.rs:    pub fn capacity(&self) -> usize {
    os/unix/net/ancillary.rs:    pub fn is_empty(&self) -> bool {
    os/unix/net/ancillary.rs:    pub fn len(&self) -> usize {
    os/unix/net/ancillary.rs:    pub fn messages(&self) -> Messages<'_> {
    os/unix/net/ancillary.rs:    pub fn truncated(&self) -> bool {
    os/unix/net/ancillary.rs:    pub fn add_fds(&mut self, fds: &[RawFd]) -> bool {
    os/unix/net/ancillary.rs:    pub fn add_creds(&mut self, creds: &[SocketCred]) -> bool {
    os/unix/net/ancillary.rs:    pub fn clear(&mut self) {
    os/unix/ucred.rs:    pub fn peer_cred(socket: &UnixStream) -> io::Result<UCred> {
    os/unix/ucred.rs:    pub fn peer_cred(socket: &UnixStream) -> io::Result<UCred> {
    os/unix/ucred.rs:    pub fn peer_cred(socket: &UnixStream) -> io::Result<UCred> {
    os/unix/process.rs:pub fn parent_id() -> u32 {
    os/unix/fs.rs:pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {
    os/unix/fs.rs:pub fn chown<P: AsRef<Path>>(dir: P, uid: Option<u32>, gid: Option<u32>) -> io::Result<()> {
    os/unix/fs.rs:pub fn fchown<F: AsFd>(fd: F, uid: Option<u32>, gid: Option<u32>) -> io::Result<()> {
    os/unix/fs.rs:pub fn lchown<P: AsRef<Path>>(dir: P, uid: Option<u32>, gid: Option<u32>) -> io::Result<()> {
    os/unix/fs.rs:pub fn chroot<P: AsRef<Path>>(dir: P) -> io::Result<()> {
    os/fd/owned.rs:    pub fn try_clone(&self) -> crate::io::Result<Self> {
    os/fd/owned.rs:    pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedFd> {
    os/fd/owned.rs:    pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedFd> {
    os/windows/io/socket.rs:    pub fn try_clone(&self) -> io::Result<Self> {
    os/windows/io/socket.rs:    pub fn try_clone_to_owned(&self) -> io::Result<OwnedSocket> {
    os/windows/io/handle.rs:    pub fn try_clone(&self) -> crate::io::Result<Self> {
    os/windows/io/handle.rs:    pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedHandle> {
    os/windows/fs.rs:pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {
    os/windows/fs.rs:pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {
    os/fortanix_sgx/arch.rs:pub fn egetkey(request: &Align512<[u8; 512]>) -> Result<Align16<[u8; 16]>, u32> {
    os/fortanix_sgx/arch.rs:pub fn ereport(

io/error.rs:    pub fn new<E>(kind: ErrorKind, error: E) -> Error
io/error.rs:    pub fn other<E>(error: E) -> Error
io/error.rs:    pub fn last_os_error() -> Error {
io/error.rs:    pub fn from_raw_os_error(code: RawOsError) -> Error {
io/error.rs:    pub fn raw_os_error(&self) -> Option<RawOsError> {
io/error.rs:    pub fn get_ref(&self) -> Option<&(dyn error::Error + Send + Sync + 'static)> {
io/error.rs:    pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> {
io/error.rs:    pub fn into_inner(self) -> Option<Box<dyn error::Error + Send + Sync>> {
io/error.rs:    pub fn downcast<E>(self) -> result::Result<Box<E>, Self>
io/error.rs:    pub fn kind(&self) -> ErrorKind {
io/mod.rs:pub fn read_to_string<R: Read>(mut reader: R) -> Result<String> {
io/mod.rs:    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {
io/mod.rs:    pub fn advance(&mut self, n: usize) {
io/mod.rs:    pub fn advance_slices(bufs: &mut &mut [IoSliceMut<'a>], n: usize) {
io/mod.rs:    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {
io/mod.rs:    pub fn advance(&mut self, n: usize) {
io/mod.rs:    pub fn advance_slices(bufs: &mut &mut [IoSlice<'a>], n: usize) {
io/mod.rs:    pub fn into_inner(self) -> (T, U) {
io/mod.rs:    pub fn get_ref(&self) -> (&T, &U) {
io/mod.rs:    pub fn get_mut(&mut self) -> (&mut T, &mut U) {
io/mod.rs:    pub fn limit(&self) -> u64 {
io/mod.rs:    pub fn set_limit(&mut self, limit: u64) {
io/mod.rs:    pub fn into_inner(self) -> T {
io/mod.rs:    pub fn get_ref(&self) -> &T {
io/mod.rs:    pub fn get_mut(&mut self) -> &mut T {
io/readbuf.rs:    pub fn capacity(&self) -> usize {
io/readbuf.rs:    pub fn len(&self) -> usize {
io/readbuf.rs:    pub fn init_len(&self) -> usize {
io/readbuf.rs:    pub fn filled(&self) -> &[u8] {
io/readbuf.rs:    pub fn unfilled<'this>(&'this mut self) -> BorrowedCursor<'this> {
io/readbuf.rs:    pub fn clear(&mut self) -> &mut Self {
io/readbuf.rs:    pub fn reborrow<'this>(&'this mut self) -> BorrowedCursor<'this> {
io/readbuf.rs:    pub fn capacity(&self) -> usize {
io/readbuf.rs:    pub fn written(&self) -> usize {
io/readbuf.rs:    pub fn init_ref(&self) -> &[u8] {
io/readbuf.rs:    pub fn init_mut(&mut self) -> &mut [u8] {
io/readbuf.rs:    pub fn uninit_mut(&mut self) -> &mut [MaybeUninit<u8>] {
io/readbuf.rs:    pub fn ensure_init(&mut self) -> &mut Self {
io/readbuf.rs:    pub fn append(&mut self, buf: &[u8]) {
io/cursor.rs:    pub fn into_inner(self) -> T {
io/cursor.rs:    pub fn get_mut(&mut self) -> &mut T {
io/cursor.rs:    pub fn set_position(&mut self, pos: u64) {
io/cursor.rs:    pub fn remaining_slice(&self) -> &[u8] {
io/cursor.rs:    pub fn is_empty(&self) -> bool {
io/stdio.rs:pub fn stdin() -> Stdin {
io/stdio.rs:    pub fn lock(&self) -> StdinLock<'static> {
io/stdio.rs:    pub fn read_line(&self, buf: &mut String) -> io::Result<usize> {
io/stdio.rs:    pub fn lines(self) -> Lines<StdinLock<'static>> {
io/stdio.rs:pub fn stdout() -> Stdout {
io/stdio.rs:pub fn cleanup() {
io/stdio.rs:    pub fn lock(&self) -> StdoutLock<'static> {
io/stdio.rs:pub fn stderr() -> Stderr {
io/stdio.rs:    pub fn lock(&self) -> StderrLock<'static> {
io/stdio.rs:pub fn set_output_capture(sink: Option<LocalStream>) -> Option<LocalStream> {
io/stdio.rs:pub fn _print(args: fmt::Arguments<'_>) {
io/stdio.rs:pub fn _eprint(args: fmt::Arguments<'_>) {
io/buffered/bufreader/buffer.rs:    pub fn with_capacity(capacity: usize) -> Self {
io/buffered/bufreader/buffer.rs:    pub fn buffer(&self) -> &[u8] {
io/buffered/bufreader/buffer.rs:    pub fn capacity(&self) -> usize {
io/buffered/bufreader/buffer.rs:    pub fn filled(&self) -> usize {
io/buffered/bufreader/buffer.rs:    pub fn pos(&self) -> usize {
io/buffered/bufreader/buffer.rs:    pub fn initialized(&self) -> usize {
io/buffered/bufreader/buffer.rs:    pub fn discard_buffer(&mut self) {
io/buffered/bufreader/buffer.rs:    pub fn consume(&mut self, amt: usize) {
io/buffered/bufreader/buffer.rs:    pub fn consume_with<V>(&mut self, amt: usize, mut visitor: V) -> bool
io/buffered/bufreader/buffer.rs:    pub fn unconsume(&mut self, amt: usize) {
io/buffered/bufreader/buffer.rs:    pub fn fill_buf(&mut self, mut reader: impl Read) -> io::Result<&[u8]> {
io/buffered/mod.rs:    pub fn error(&self) -> &Error {
io/buffered/mod.rs:    pub fn into_inner(self) -> W {
io/buffered/mod.rs:    pub fn into_error(self) -> Error {
io/buffered/mod.rs:    pub fn into_parts(self) -> (Error, W) {
io/buffered/bufreader.rs:    pub fn new(inner: R) -> BufReader<R> {
io/buffered/bufreader.rs:    pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {
io/buffered/bufreader.rs:    pub fn get_ref(&self) -> &R {
io/buffered/bufreader.rs:    pub fn get_mut(&mut self) -> &mut R {
io/buffered/bufreader.rs:    pub fn buffer(&self) -> &[u8] {
io/buffered/bufreader.rs:    pub fn capacity(&self) -> usize {
io/buffered/bufreader.rs:    pub fn into_inner(self) -> R {
io/buffered/bufreader.rs:    pub fn initialized(&self) -> usize {
io/buffered/bufreader.rs:    pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {
io/buffered/linewritershim.rs:    pub fn new(buffer: &'a mut BufWriter<W>) -> Self {
io/buffered/bufwriter.rs:    pub fn new(inner: W) -> BufWriter<W> {
io/buffered/bufwriter.rs:    pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {
io/buffered/bufwriter.rs:    pub fn get_ref(&self) -> &W {
io/buffered/bufwriter.rs:    pub fn get_mut(&mut self) -> &mut W {
io/buffered/bufwriter.rs:    pub fn buffer(&self) -> &[u8] {
io/buffered/bufwriter.rs:    pub fn capacity(&self) -> usize {
io/buffered/bufwriter.rs:    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {
io/buffered/bufwriter.rs:    pub fn into_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {
io/buffered/bufwriter.rs:    pub fn into_inner(self) -> Vec<u8> {
io/buffered/linewriter.rs:    pub fn new(inner: W) -> LineWriter<W> {
io/buffered/linewriter.rs:    pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {
io/buffered/linewriter.rs:    pub fn get_ref(&self) -> &W {
io/buffered/linewriter.rs:    pub fn get_mut(&mut self) -> &mut W {
io/buffered/linewriter.rs:    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {
io/copy.rs:pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>

sync/barrier.rs:    pub fn new(n: usize) -> Barrier {
sync/barrier.rs:    pub fn wait(&self) -> BarrierWaitResult {
sync/barrier.rs:    pub fn is_leader(&self) -> bool {
sync/mpmc/utils.rs:    pub fn new(value: T) -> CachePadded<T> {
sync/mpmc/utils.rs:    pub fn new() -> Self {
sync/mpmc/utils.rs:    pub fn spin_light(&self) {
sync/mpmc/utils.rs:    pub fn spin_heavy(&self) {
sync/mpmc/mod.rs:pub fn channel<T>() -> (Sender<T>, Receiver<T>) {
sync/mpmc/mod.rs:pub fn sync_channel<T>(cap: usize) -> (Sender<T>, Receiver<T>) {
sync/mpmc/mod.rs:    pub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {
sync/mpmc/mod.rs:    pub fn send(&self, msg: T) -> Result<(), SendError<T>> {
sync/mpmc/mod.rs:    pub fn send_timeout(&self, msg: T, timeout: Duration) -> Result<(), SendTimeoutError<T>> {
sync/mpmc/mod.rs:    pub fn send_deadline(&self, msg: T, deadline: Instant) -> Result<(), SendTimeoutError<T>> {
sync/mpmc/mod.rs:    pub fn is_empty(&self) -> bool {
sync/mpmc/mod.rs:    pub fn is_full(&self) -> bool {
sync/mpmc/mod.rs:    pub fn len(&self) -> usize {
sync/mpmc/mod.rs:    pub fn capacity(&self) -> Option<usize> {
sync/mpmc/mod.rs:    pub fn same_channel(&self, other: &Sender<T>) -> bool {
sync/mpmc/mod.rs:    pub fn try_recv(&self) -> Result<T, TryRecvError> {
sync/mpmc/mod.rs:    pub fn recv(&self) -> Result<T, RecvError> {
sync/mpmc/mod.rs:    pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {
sync/mpmc/mod.rs:    pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {
sync/mpmc/mod.rs:    pub fn is_empty(&self) -> bool {
sync/mpmc/mod.rs:    pub fn is_full(&self) -> bool {
sync/mpmc/mod.rs:    pub fn len(&self) -> usize {
sync/mpmc/mod.rs:    pub fn capacity(&self) -> Option<usize> {
sync/mpmc/mod.rs:    pub fn same_channel(&self, other: &Receiver<T>) -> bool {
sync/mpmc/select.rs:    pub fn hook<T>(r: &mut T) -> Operation {
sync/mpmc/context.rs:    pub fn with<F, R>(f: F) -> R
sync/mpmc/context.rs:    pub fn try_select(&self, select: Selected) -> Result<(), Selected> {
sync/mpmc/context.rs:    pub fn store_packet(&self, packet: *mut ()) {
sync/mpmc/context.rs:    pub fn wait_until(&self, deadline: Option<Instant>) -> Selected {
sync/mpmc/context.rs:    pub fn unpark(&self) {
sync/mpmc/context.rs:    pub fn thread_id(&self) -> usize {
sync/mpmc/waker.rs:pub fn current_thread_id() -> usize {
sync/lazy_lock.rs:    pub fn force(this: &LazyLock<T, F>) -> &T {
sync/mpsc/tests.rs:pub fn stress_factor() -> usize {
sync/mpsc/mod.rs:pub fn channel<T>() -> (Sender<T>, Receiver<T>) {
sync/mpsc/mod.rs:pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {
sync/mpsc/mod.rs:    pub fn send(&self, t: T) -> Result<(), SendError<T>> {
sync/mpsc/mod.rs:    pub fn send(&self, t: T) -> Result<(), SendError<T>> {
sync/mpsc/mod.rs:    pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {
sync/mpsc/mod.rs:    pub fn try_recv(&self) -> Result<T, TryRecvError> {
sync/mpsc/mod.rs:    pub fn recv(&self) -> Result<T, RecvError> {
sync/mpsc/mod.rs:    pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {
sync/mpsc/mod.rs:    pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {
sync/mpsc/mod.rs:    pub fn iter(&self) -> Iter<'_, T> {
sync/mpsc/mod.rs:    pub fn try_iter(&self) -> TryIter<'_, T> {
sync/mpsc/sync_tests.rs:pub fn stress_factor() -> usize {
sync/poison.rs:    pub fn borrow(&self) -> LockResult<()> {
sync/poison.rs:    pub fn guard(&self) -> LockResult<Guard> {
sync/poison.rs:    pub fn done(&self, guard: &Guard) {
sync/poison.rs:    pub fn get(&self) -> bool {
sync/poison.rs:    pub fn clear(&self) {
sync/poison.rs:    pub fn new(guard: T) -> PoisonError<T> {
sync/poison.rs:    pub fn into_inner(self) -> T {
sync/poison.rs:    pub fn get_ref(&self) -> &T {
sync/poison.rs:    pub fn get_mut(&mut self) -> &mut T {
sync/poison.rs:pub fn map_result<T, U, F>(result: LockResult<T>, f: F) -> LockResult<U>
sync/once_lock.rs:    pub fn get(&self) -> Option<&T> {
sync/once_lock.rs:    pub fn get_mut(&mut self) -> Option<&mut T> {
sync/once_lock.rs:    pub fn set(&self, value: T) -> Result<(), T> {
sync/once_lock.rs:    pub fn get_or_init<F>(&self, f: F) -> &T
sync/once_lock.rs:    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>
sync/once_lock.rs:    pub fn into_inner(mut self) -> Option<T> {
sync/once_lock.rs:    pub fn take(&mut self) -> Option<T> {
sync/rwlock.rs:    pub fn read(&self) -> LockResult<RwLockReadGuard<'_, T>> {
sync/rwlock.rs:    pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<'_, T>> {
sync/rwlock.rs:    pub fn write(&self) -> LockResult<RwLockWriteGuard<'_, T>> {
sync/rwlock.rs:    pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<'_, T>> {
sync/rwlock.rs:    pub fn is_poisoned(&self) -> bool {
sync/rwlock.rs:    pub fn clear_poison(&self) {
sync/rwlock.rs:    pub fn into_inner(self) -> LockResult<T>
sync/rwlock.rs:    pub fn get_mut(&mut self) -> LockResult<&mut T> {
sync/remutex.rs:    pub fn lock(&self) -> ReentrantMutexGuard<'_, T> {
sync/remutex.rs:    pub fn try_lock(&self) -> Option<ReentrantMutexGuard<'_, T>> {
sync/remutex.rs:pub fn current_thread_unique_ptr() -> usize {
sync/once.rs:    pub fn call_once<F>(&self, f: F)
sync/once.rs:    pub fn call_once_force<F>(&self, f: F)
sync/once.rs:    pub fn is_completed(&self) -> bool {
sync/once.rs:    pub fn is_poisoned(&self) -> bool {
sync/condvar.rs:    pub fn timed_out(&self) -> bool {
sync/condvar.rs:    pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>) -> LockResult<MutexGuard<'a, T>> {
sync/condvar.rs:    pub fn wait_while<'a, T, F>(
sync/condvar.rs:    pub fn wait_timeout_ms<'a, T>(
sync/condvar.rs:    pub fn wait_timeout<'a, T>(
sync/condvar.rs:    pub fn wait_timeout_while<'a, T, F>(
sync/condvar.rs:    pub fn notify_one(&self) {
sync/condvar.rs:    pub fn notify_all(&self) {
sync/mutex.rs:    pub fn lock(&self) -> LockResult<MutexGuard<'_, T>> {
sync/mutex.rs:    pub fn try_lock(&self) -> TryLockResult<MutexGuard<'_, T>> {
sync/mutex.rs:    pub fn unlock(guard: MutexGuard<'_, T>) {
sync/mutex.rs:    pub fn is_poisoned(&self) -> bool {
sync/mutex.rs:    pub fn clear_poison(&self) {
sync/mutex.rs:    pub fn into_inner(self) -> LockResult<T>
sync/mutex.rs:    pub fn get_mut(&mut self) -> LockResult<&mut T> {
sync/mutex.rs:pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {
sync/mutex.rs:pub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {

net/tcp.rs:    pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> {
net/tcp.rs:    pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {
net/tcp.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
net/tcp.rs:    pub fn local_addr(&self) -> io::Result<SocketAddr> {
net/tcp.rs:    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {
net/tcp.rs:    pub fn try_clone(&self) -> io::Result<TcpStream> {
net/tcp.rs:    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
net/tcp.rs:    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
net/tcp.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
net/tcp.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
net/tcp.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
net/tcp.rs:    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {
net/tcp.rs:    pub fn linger(&self) -> io::Result<Option<Duration>> {
net/tcp.rs:    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {
net/tcp.rs:    pub fn nodelay(&self) -> io::Result<bool> {
net/tcp.rs:    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {
net/tcp.rs:    pub fn ttl(&self) -> io::Result<u32> {
net/tcp.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
net/tcp.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
net/tcp.rs:    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {
net/tcp.rs:    pub fn local_addr(&self) -> io::Result<SocketAddr> {
net/tcp.rs:    pub fn try_clone(&self) -> io::Result<TcpListener> {
net/tcp.rs:    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {
net/tcp.rs:    pub fn incoming(&self) -> Incoming<'_> {
net/tcp.rs:    pub fn into_incoming(self) -> IntoIncoming {
net/tcp.rs:    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {
net/tcp.rs:    pub fn ttl(&self) -> io::Result<u32> {
net/tcp.rs:    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {
net/tcp.rs:    pub fn only_v6(&self) -> io::Result<bool> {
net/tcp.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
net/tcp.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
net/udp.rs:    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {
net/udp.rs:    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
net/udp.rs:    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {
net/udp.rs:    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A) -> io::Result<usize> {
net/udp.rs:    pub fn peer_addr(&self) -> io::Result<SocketAddr> {
net/udp.rs:    pub fn local_addr(&self) -> io::Result<SocketAddr> {
net/udp.rs:    pub fn try_clone(&self) -> io::Result<UdpSocket> {
net/udp.rs:    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
net/udp.rs:    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {
net/udp.rs:    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {
net/udp.rs:    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {
net/udp.rs:    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {
net/udp.rs:    pub fn broadcast(&self) -> io::Result<bool> {
net/udp.rs:    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {
net/udp.rs:    pub fn multicast_loop_v4(&self) -> io::Result<bool> {
net/udp.rs:    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {
net/udp.rs:    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {
net/udp.rs:    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {
net/udp.rs:    pub fn multicast_loop_v6(&self) -> io::Result<bool> {
net/udp.rs:    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {
net/udp.rs:    pub fn ttl(&self) -> io::Result<u32> {
net/udp.rs:    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {
net/udp.rs:    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {
net/udp.rs:    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {
net/udp.rs:    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {
net/udp.rs:    pub fn take_error(&self) -> io::Result<Option<io::Error>> {
net/udp.rs:    pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {
net/udp.rs:    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {
net/udp.rs:    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {
net/udp.rs:    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
net/udp.rs:    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
net/test.rs:pub fn next_test_ip4() -> SocketAddr {
net/test.rs:pub fn next_test_ip6() -> SocketAddr {
net/test.rs:pub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {
net/test.rs:pub fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr {
net/test.rs:pub fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> {

backtrace_rs/types.rs:    pub fn to_str_lossy(&self) -> Cow<'a, str> {
backtrace_rs/types.rs:    pub fn into_path_buf(self) -> PathBuf {
backtrace_rs/mod.rs:    pub fn lock() -> LockGuard {
backtrace_rs/symbolize/noop.rs:    pub fn name(&self) -> Option<SymbolName<'_>> {
backtrace_rs/symbolize/noop.rs:    pub fn addr(&self) -> Option<*mut c_void> {
backtrace_rs/symbolize/noop.rs:    pub fn filename_raw(&self) -> Option<BytesOrWideString<'_>> {
backtrace_rs/symbolize/noop.rs:    pub fn filename(&self) -> Option<&::std::path::Path> {
backtrace_rs/symbolize/noop.rs:    pub fn lineno(&self) -> Option<u32> {
backtrace_rs/symbolize/noop.rs:    pub fn colno(&self) -> Option<u32> {
backtrace_rs/symbolize/mod.rs:pub fn resolve<F: FnMut(&Symbol)>(addr: *mut c_void, cb: F) {
backtrace_rs/symbolize/mod.rs:pub fn resolve_frame<F: FnMut(&Symbol)>(frame: &Frame, cb: F) {
backtrace_rs/symbolize/mod.rs:    pub fn name(&self) -> Option<SymbolName<'_>> {
backtrace_rs/symbolize/mod.rs:    pub fn addr(&self) -> Option<*mut c_void> {
backtrace_rs/symbolize/mod.rs:    pub fn filename_raw(&self) -> Option<BytesOrWideString<'_>> {
backtrace_rs/symbolize/mod.rs:    pub fn colno(&self) -> Option<u32> {
backtrace_rs/symbolize/mod.rs:    pub fn lineno(&self) -> Option<u32> {
backtrace_rs/symbolize/mod.rs:    pub fn filename(&self) -> Option<&Path> {
backtrace_rs/symbolize/mod.rs:    pub fn new(bytes: &'a [u8]) -> SymbolName<'a> {
backtrace_rs/symbolize/mod.rs:    pub fn as_str(&self) -> Option<&'a str> {
backtrace_rs/symbolize/mod.rs:    pub fn as_bytes(&self) -> &'a [u8] {
backtrace_rs/symbolize/mod.rs:pub fn clear_symbol_cache() {
backtrace_rs/symbolize/gimli.rs:    pub fn name(&self) -> Option<SymbolName<'_>> {
backtrace_rs/symbolize/gimli.rs:    pub fn addr(&self) -> Option<*mut c_void> {
backtrace_rs/symbolize/gimli.rs:    pub fn filename_raw(&self) -> Option<BytesOrWideString<'_>> {
backtrace_rs/symbolize/gimli.rs:    pub fn filename(&self) -> Option<&Path> {
backtrace_rs/symbolize/gimli.rs:    pub fn lineno(&self) -> Option<u32> {
backtrace_rs/symbolize/gimli.rs:    pub fn colno(&self) -> Option<u32> {
backtrace_rs/symbolize/gimli/macho.rs:    pub fn new(path: &Path) -> Option<Mapping> {
backtrace_rs/symbolize/gimli/macho.rs:    pub fn section(&self, _: &Stash, name: &str) -> Option<&'a [u8]> {
backtrace_rs/symbolize/gimli/macho.rs:    pub fn search_symtab<'b>(&'b self, addr: u64) -> Option<&'b [u8]> {
backtrace_rs/symbolize/gimli/elf.rs:    pub fn new(path: &Path) -> Option<Mapping> {
backtrace_rs/symbolize/gimli/elf.rs:    pub fn section(&self, stash: &'a Stash, name: &str) -> Option<&'a [u8]> {
backtrace_rs/symbolize/gimli/elf.rs:    pub fn search_symtab<'b>(&'b self, addr: u64) -> Option<&'b [u8]> {
backtrace_rs/symbolize/gimli/stash.rs:    pub fn new() -> Stash {
backtrace_rs/symbolize/gimli/stash.rs:    pub fn allocate(&self, size: usize) -> &mut [u8] {
backtrace_rs/symbolize/gimli/stash.rs:    pub fn set_mmap_aux(&self, map: Mmap) -> &[u8] {
backtrace_rs/symbolize/gimli/coff.rs:    pub fn new(path: &Path) -> Option<Mapping> {
backtrace_rs/symbolize/gimli/coff.rs:pub fn get_image_base(data: &[u8]) -> Option<usize> {
backtrace_rs/symbolize/gimli/coff.rs:    pub fn section(&self, _: &Stash, name: &str) -> Option<&'a [u8]> {
backtrace_rs/symbolize/gimli/coff.rs:    pub fn search_symtab<'b>(&'b self, addr: u64) -> Option<&'b [u8]> {
backtrace_rs/symbolize/miri.rs:    pub fn name(&self) -> Option<SymbolName<'_>> {
backtrace_rs/symbolize/miri.rs:    pub fn addr(&self) -> Option<*mut c_void> {
backtrace_rs/symbolize/miri.rs:    pub fn filename_raw(&self) -> Option<BytesOrWideString<'_>> {
backtrace_rs/symbolize/miri.rs:    pub fn lineno(&self) -> Option<u32> {
backtrace_rs/symbolize/miri.rs:    pub fn colno(&self) -> Option<u32> {
backtrace_rs/symbolize/miri.rs:    pub fn filename(&self) -> Option<&std::path::Path> {
backtrace_rs/symbolize/dbghelp.rs:    pub fn name(&self) -> Option<SymbolName<'_>> {
backtrace_rs/symbolize/dbghelp.rs:    pub fn addr(&self) -> Option<*mut c_void> {
backtrace_rs/symbolize/dbghelp.rs:    pub fn filename_raw(&self) -> Option<BytesOrWideString<'_>> {
backtrace_rs/symbolize/dbghelp.rs:    pub fn colno(&self) -> Option<u32> {
backtrace_rs/symbolize/dbghelp.rs:    pub fn lineno(&self) -> Option<u32> {
backtrace_rs/symbolize/dbghelp.rs:    pub fn filename(&self) -> Option<&::std::path::Path> {
backtrace_rs/windows.rs:    (extern "system" { $(pub fn $name:ident($($args:tt)*) -> $ret:ty;)* } $($rest:tt)*) => (
backtrace_rs/windows.rs:            $(pub fn $name($($args)*) -> $ret;)*
backtrace_rs/windows.rs:        pub fn GetCurrentProcess() -> HANDLE;
backtrace_rs/windows.rs:        pub fn GetCurrentThread() -> HANDLE;
backtrace_rs/windows.rs:        pub fn RtlCaptureContext(ContextRecord: PCONTEXT) -> ();
backtrace_rs/windows.rs:        pub fn LoadLibraryA(a: *const i8) -> HMODULE;
backtrace_rs/windows.rs:        pub fn GetProcAddress(h: HMODULE, name: *const i8) -> FARPROC;
backtrace_rs/windows.rs:        pub fn GetModuleHandleA(name: *const i8) -> HMODULE;
backtrace_rs/windows.rs:        pub fn OpenProcess(
backtrace_rs/windows.rs:        pub fn GetCurrentProcessId() -> DWORD;
backtrace_rs/windows.rs:        pub fn CloseHandle(h: HANDLE) -> BOOL;
backtrace_rs/windows.rs:        pub fn CreateFileA(
backtrace_rs/windows.rs:        pub fn CreateMutexA(
backtrace_rs/windows.rs:        pub fn ReleaseMutex(hMutex: HANDLE) -> BOOL;
backtrace_rs/windows.rs:        pub fn WaitForSingleObjectEx(
backtrace_rs/windows.rs:        pub fn CreateFileMappingA(
backtrace_rs/windows.rs:        pub fn MapViewOfFile(
backtrace_rs/windows.rs:        pub fn UnmapViewOfFile(lpBaseAddress: LPCVOID) -> BOOL;
backtrace_rs/windows.rs:        pub fn CreateToolhelp32Snapshot(
backtrace_rs/windows.rs:        pub fn Module32FirstW(
backtrace_rs/windows.rs:        pub fn Module32NextW(
backtrace_rs/windows.rs:        pub fn RtlLookupFunctionEntry(
backtrace_rs/print/fuchsia.rs:pub fn print_dso_context(out: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
backtrace_rs/backtrace/noop.rs:pub fn trace(_cb: &mut dyn FnMut(&super::Frame) -> bool) {}
backtrace_rs/backtrace/noop.rs:    pub fn ip(&self) -> *mut c_void {
backtrace_rs/backtrace/noop.rs:    pub fn sp(&self) -> *mut c_void {
backtrace_rs/backtrace/noop.rs:    pub fn symbol_address(&self) -> *mut c_void {
backtrace_rs/backtrace/noop.rs:    pub fn module_base_address(&self) -> Option<*mut c_void> {
backtrace_rs/backtrace/mod.rs:pub fn trace<F: FnMut(&Frame) -> bool>(cb: F) {
backtrace_rs/backtrace/mod.rs:    pub fn ip(&self) -> *mut c_void {
backtrace_rs/backtrace/mod.rs:    pub fn sp(&self) -> *mut c_void {
backtrace_rs/backtrace/mod.rs:    pub fn symbol_address(&self) -> *mut c_void {
backtrace_rs/backtrace/mod.rs:    pub fn module_base_address(&self) -> Option<*mut c_void> {
backtrace_rs/backtrace/miri.rs:    pub fn_ptr: *mut c_void,
backtrace_rs/backtrace/miri.rs:    pub fn_ptr: *mut c_void,
backtrace_rs/backtrace/miri.rs:    pub fn ip(&self) -> *mut c_void {
backtrace_rs/backtrace/miri.rs:    pub fn sp(&self) -> *mut c_void {
backtrace_rs/backtrace/miri.rs:    pub fn symbol_address(&self) -> *mut c_void {
backtrace_rs/backtrace/miri.rs:    pub fn module_base_address(&self) -> Option<*mut c_void> {
backtrace_rs/backtrace/miri.rs:pub fn trace<F: FnMut(&super::Frame) -> bool>(cb: F) {
backtrace_rs/backtrace/miri.rs:pub fn resolve_addr(ptr: *mut c_void) -> Frame {
backtrace_rs/backtrace/dbghelp.rs:    pub fn ip(&self) -> *mut c_void {
backtrace_rs/backtrace/dbghelp.rs:    pub fn sp(&self) -> *mut c_void {
backtrace_rs/backtrace/dbghelp.rs:    pub fn symbol_address(&self) -> *mut c_void {
backtrace_rs/backtrace/dbghelp.rs:    pub fn module_base_address(&self) -> Option<*mut c_void> {
backtrace_rs/backtrace/libunwind.rs:    pub fn ip(&self) -> *mut c_void {
backtrace_rs/backtrace/libunwind.rs:    pub fn sp(&self) -> *mut c_void {
backtrace_rs/backtrace/libunwind.rs:    pub fn symbol_address(&self) -> *mut c_void {
backtrace_rs/backtrace/libunwind.rs:    pub fn module_base_address(&self) -> Option<*mut c_void> {
backtrace_rs/backtrace/libunwind.rs:        pub fn _Unwind_Backtrace(
backtrace_rs/backtrace/libunwind.rs:                pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;
backtrace_rs/backtrace/libunwind.rs:                pub fn _Unwind_FindEnclosingFunction(pc: *mut c_void) -> *mut c_void;
backtrace_rs/backtrace/libunwind.rs:                pub fn get_sp(ctx: *mut _Unwind_Context) -> libc::uintptr_t;
backtrace_rs/backtrace/libunwind.rs:                    pub fn _Unwind_GetGR(ctx: *mut _Unwind_Context, index: libc::c_int) -> libc::uintptr_t;
backtrace_rs/print.rs:    pub fn new(
backtrace_rs/print.rs:    pub fn add_context(&mut self) -> fmt::Result {
backtrace_rs/print.rs:    pub fn frame(&mut self) -> BacktraceFrameFmt<'_, 'a, 'b> {
backtrace_rs/print.rs:    pub fn finish(&mut self) -> fmt::Result {
backtrace_rs/print.rs:    pub fn backtrace_frame(&mut self, frame: &BacktraceFrame) -> fmt::Result {
backtrace_rs/print.rs:    pub fn backtrace_symbol(
backtrace_rs/print.rs:    pub fn symbol(&mut self, frame: &Frame, symbol: &super::Symbol) -> fmt::Result {
backtrace_rs/print.rs:    pub fn print_raw(
backtrace_rs/print.rs:    pub fn print_raw_with_column(
backtrace_rs/dbghelp.rs:        pub fn SymFromInlineContextW(
backtrace_rs/dbghelp.rs:        pub fn SymGetLineFromInlineContextW(
backtrace_rs/dbghelp.rs:    pub fn assert_equal_types<T>(a: T, _b: T) -> T {
backtrace_rs/dbghelp.rs:            $(pub fn $name(&mut self) -> Option<$name> {
backtrace_rs/dbghelp.rs:            $(pub fn $name(&self) -> $name {
backtrace_rs/dbghelp.rs:            pub fn dbghelp(&self) -> *mut Dbghelp {
backtrace_rs/dbghelp.rs:pub fn init() -> Result<Init, ()> {
backtrace_rs/capture.rs:    pub fn new() -> Backtrace {
backtrace_rs/capture.rs:    pub fn new_unresolved() -> Backtrace {
backtrace_rs/capture.rs:    pub fn frames(&self) -> &[BacktraceFrame] {
backtrace_rs/capture.rs:    pub fn resolve(&mut self) {
backtrace_rs/capture.rs:    pub fn ip(&self) -> *mut c_void {
backtrace_rs/capture.rs:    pub fn symbol_address(&self) -> *mut c_void {
backtrace_rs/capture.rs:    pub fn module_base_address(&self) -> Option<*mut c_void> {
backtrace_rs/capture.rs:    pub fn symbols(&self) -> &[BacktraceSymbol] {
backtrace_rs/capture.rs:    pub fn name(&self) -> Option<SymbolName<'_>> {
backtrace_rs/capture.rs:    pub fn addr(&self) -> Option<*mut c_void> {
backtrace_rs/capture.rs:    pub fn filename(&self) -> Option<&Path> {
backtrace_rs/capture.rs:    pub fn lineno(&self) -> Option<u32> {
backtrace_rs/capture.rs:    pub fn colno(&self) -> Option<u32> {

panic.rs:pub fn panic_any<M: 'static + Any + Send>(msg: M) -> ! {
panic.rs:pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {
panic.rs:pub fn resume_unwind(payload: Box<dyn Any + Send>) -> ! {
panic.rs:pub fn always_abort() {
panic.rs:pub fn set_backtrace_style(style: BacktraceStyle) {
panic.rs:pub fn get_backtrace_style() -> Option<BacktraceStyle> {
error.rs:    pub fn new(error: E) -> Report<E> {
error.rs:    pub fn pretty(mut self, pretty: bool) -> Self {
error.rs:    pub fn show_backtrace(mut self, show_backtrace: bool) -> Self {
fs/tests.rs:pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {
panicking.rs:pub fn set_hook(hook: Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send>) {
panicking.rs:pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {
panicking.rs:pub fn update_hook<F>(hook_fn: F)
panicking.rs:    pub fn increase() -> (bool, usize) {
panicking.rs:    pub fn decrease() {
panicking.rs:    pub fn set_always_abort() {
panicking.rs:    pub fn get_count() -> usize {
panicking.rs:    pub fn count_is_zero() -> bool {
panicking.rs:pub fn panicking() -> bool {
panicking.rs:pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {
panicking.rs:pub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {

thread/scoped.rs:pub fn scope<'env, F, T>(f: F) -> T
thread/scoped.rs:    pub fn spawn<F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>
thread/scoped.rs:    pub fn spawn_scoped<'scope, 'env, F, T>(
thread/scoped.rs:    pub fn thread(&self) -> &Thread {
thread/scoped.rs:    pub fn join(self) -> Result<T> {
thread/scoped.rs:    pub fn is_finished(&self) -> bool {
thread/mod.rs:    pub fn new() -> Builder {
thread/mod.rs:    pub fn name(mut self, name: String) -> Builder {
thread/mod.rs:    pub fn stack_size(mut self, size: usize) -> Builder {
thread/mod.rs:    pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>>
thread/mod.rs:pub fn spawn<F, T>(f: F) -> JoinHandle<T>
thread/mod.rs:pub fn current() -> Thread {
thread/mod.rs:pub fn yield_now() {
thread/mod.rs:pub fn panicking() -> bool {
thread/mod.rs:pub fn sleep_ms(ms: u32) {
thread/mod.rs:pub fn sleep(dur: Duration) {
thread/mod.rs:pub fn park() {
thread/mod.rs:pub fn park_timeout_ms(ms: u32) {
thread/mod.rs:pub fn park_timeout(dur: Duration) {
thread/mod.rs:    pub fn as_u64(&self) -> NonZeroU64 {
thread/mod.rs:    pub fn unpark(&self) {
thread/mod.rs:    pub fn id(&self) -> ThreadId {
thread/mod.rs:    pub fn name(&self) -> Option<&str> {
thread/mod.rs:    pub fn thread(&self) -> &Thread {
thread/mod.rs:    pub fn join(self) -> Result<T> {
thread/mod.rs:    pub fn is_finished(&self) -> bool {
thread/mod.rs:pub fn available_parallelism() -> io::Result<NonZeroUsize> {
thread/local.rs:    pub fn with<F, R>(&'static self, f: F) -> R
thread/local.rs:    pub fn try_with<F, R>(&'static self, f: F) -> Result<R, AccessError>
thread/local.rs:    pub fn set(&'static self, value: T) {
thread/local.rs:    pub fn get(&'static self) -> T
thread/local.rs:    pub fn take(&'static self) -> T
thread/local.rs:    pub fn replace(&'static self, value: T) -> T {
thread/local.rs:    pub fn with_borrow<F, R>(&'static self, f: F) -> R
thread/local.rs:    pub fn with_borrow_mut<F, R>(&'static self, f: F) -> R
thread/local.rs:    pub fn set(&'static self, value: T) {
thread/local.rs:    pub fn take(&'static self) -> T
thread/local.rs:    pub fn replace(&'static self, value: T) -> T {
f32.rs:    pub fn floor(self) -> f32 {
f32.rs:    pub fn ceil(self) -> f32 {
f32.rs:    pub fn round(self) -> f32 {
f32.rs:    pub fn round_ties_even(self) -> f32 {
f32.rs:    pub fn trunc(self) -> f32 {
f32.rs:    pub fn fract(self) -> f32 {
f32.rs:    pub fn abs(self) -> f32 {
f32.rs:    pub fn signum(self) -> f32 {
f32.rs:    pub fn copysign(self, sign: f32) -> f32 {
f32.rs:    pub fn mul_add(self, a: f32, b: f32) -> f32 {
f32.rs:    pub fn div_euclid(self, rhs: f32) -> f32 {
f32.rs:    pub fn rem_euclid(self, rhs: f32) -> f32 {
f32.rs:    pub fn powi(self, n: i32) -> f32 {
f32.rs:    pub fn powf(self, n: f32) -> f32 {
f32.rs:    pub fn sqrt(self) -> f32 {
f32.rs:    pub fn exp(self) -> f32 {
f32.rs:    pub fn exp2(self) -> f32 {
f32.rs:    pub fn ln(self) -> f32 {
f32.rs:    pub fn log(self, base: f32) -> f32 {
f32.rs:    pub fn log2(self) -> f32 {
f32.rs:    pub fn log10(self) -> f32 {
f32.rs:    pub fn abs_sub(self, other: f32) -> f32 {
f32.rs:    pub fn cbrt(self) -> f32 {
f32.rs:    pub fn hypot(self, other: f32) -> f32 {
f32.rs:    pub fn sin(self) -> f32 {
f32.rs:    pub fn cos(self) -> f32 {
f32.rs:    pub fn tan(self) -> f32 {
f32.rs:    pub fn asin(self) -> f32 {
f32.rs:    pub fn acos(self) -> f32 {
f32.rs:    pub fn atan(self) -> f32 {
f32.rs:    pub fn atan2(self, other: f32) -> f32 {
f32.rs:    pub fn sin_cos(self) -> (f32, f32) {
f32.rs:    pub fn exp_m1(self) -> f32 {
f32.rs:    pub fn ln_1p(self) -> f32 {
f32.rs:    pub fn sinh(self) -> f32 {
f32.rs:    pub fn cosh(self) -> f32 {
f32.rs:    pub fn tanh(self) -> f32 {
f32.rs:    pub fn asinh(self) -> f32 {
f32.rs:    pub fn acosh(self) -> f32 {
f32.rs:    pub fn atanh(self) -> f32 {
path.rs:    pub fn is_verbatim(&self) -> bool {
path.rs:pub fn is_separator(c: char) -> bool {
path.rs:    pub fn kind(&self) -> Prefix<'a> {
path.rs:    pub fn as_os_str(&self) -> &'a OsStr {
path.rs:    pub fn as_os_str(self) -> &'a OsStr {
path.rs:    pub fn as_path(&self) -> &'a Path {
path.rs:    pub fn as_path(&self) -> &'a Path {
path.rs:    pub fn new() -> PathBuf {
path.rs:    pub fn with_capacity(capacity: usize) -> PathBuf {
path.rs:    pub fn as_path(&self) -> &Path {
path.rs:    pub fn push<P: AsRef<Path>>(&mut self, path: P) {
path.rs:    pub fn pop(&mut self) -> bool {
path.rs:    pub fn set_file_name<S: AsRef<OsStr>>(&mut self, file_name: S) {
path.rs:    pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool {
path.rs:    pub fn as_mut_os_string(&mut self) -> &mut OsString {
path.rs:    pub fn into_os_string(self) -> OsString {
path.rs:    pub fn into_boxed_path(self) -> Box<Path> {
path.rs:    pub fn capacity(&self) -> usize {
path.rs:    pub fn clear(&mut self) {
path.rs:    pub fn reserve(&mut self, additional: usize) {
path.rs:    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
path.rs:    pub fn reserve_exact(&mut self, additional: usize) {
path.rs:    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
path.rs:    pub fn shrink_to_fit(&mut self) {
path.rs:    pub fn shrink_to(&mut self, min_capacity: usize) {
path.rs:    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path {
path.rs:    pub fn as_os_str(&self) -> &OsStr {
path.rs:    pub fn as_mut_os_str(&mut self) -> &mut OsStr {
path.rs:    pub fn to_str(&self) -> Option<&str> {
path.rs:    pub fn to_string_lossy(&self) -> Cow<'_, str> {
path.rs:    pub fn to_path_buf(&self) -> PathBuf {
path.rs:    pub fn is_absolute(&self) -> bool {
path.rs:    pub fn is_relative(&self) -> bool {
path.rs:    pub fn has_root(&self) -> bool {
path.rs:    pub fn parent(&self) -> Option<&Path> {
path.rs:    pub fn ancestors(&self) -> Ancestors<'_> {
path.rs:    pub fn file_name(&self) -> Option<&OsStr> {
path.rs:    pub fn strip_prefix<P>(&self, base: P) -> Result<&Path, StripPrefixError>
path.rs:    pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {
path.rs:    pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool {
path.rs:    pub fn file_stem(&self) -> Option<&OsStr> {
path.rs:    pub fn file_prefix(&self) -> Option<&OsStr> {
path.rs:    pub fn extension(&self) -> Option<&OsStr> {
path.rs:    pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf {
path.rs:    pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf {
path.rs:    pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {
path.rs:    pub fn components(&self) -> Components<'_> {
path.rs:    pub fn iter(&self) -> Iter<'_> {
path.rs:    pub fn display(&self) -> Display<'_> {
path.rs:    pub fn metadata(&self) -> io::Result<fs::Metadata> {
path.rs:    pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> {
path.rs:    pub fn canonicalize(&self) -> io::Result<PathBuf> {
path.rs:    pub fn read_link(&self) -> io::Result<PathBuf> {
path.rs:    pub fn read_dir(&self) -> io::Result<fs::ReadDir> {
path.rs:    pub fn exists(&self) -> bool {
path.rs:    pub fn try_exists(&self) -> io::Result<bool> {
path.rs:    pub fn is_file(&self) -> bool {
path.rs:    pub fn is_dir(&self) -> bool {
path.rs:    pub fn is_symlink(&self) -> bool {
path.rs:    pub fn into_path_buf(self: Box<Path>) -> PathBuf {
path.rs:pub fn absolute<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {
keyword_docs.rs:/// pub fn public_thing(argument: bool) -> String {
keyword_docs.rs:///     pub fn new() -> Self {
keyword_docs.rs:///     pub fn new(name: String) -> Self {
keyword_docs.rs:///     pub fn foo() {}
keyword_docs.rs:///     pub fn foo() {
collections/hash/set.rs:    pub fn new() -> HashSet<T, RandomState> {
collections/hash/set.rs:    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {
collections/hash/set.rs:    pub fn capacity(&self) -> usize {
collections/hash/set.rs:    pub fn iter(&self) -> Iter<'_, T> {
collections/hash/set.rs:    pub fn len(&self) -> usize {
collections/hash/set.rs:    pub fn is_empty(&self) -> bool {
collections/hash/set.rs:    pub fn drain(&mut self) -> Drain<'_, T> {
collections/hash/set.rs:    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, T, F>
collections/hash/set.rs:    pub fn retain<F>(&mut self, f: F)
collections/hash/set.rs:    pub fn clear(&mut self) {
collections/hash/set.rs:    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {
collections/hash/set.rs:    pub fn hasher(&self) -> &S {
collections/hash/set.rs:    pub fn reserve(&mut self, additional: usize) {
collections/hash/set.rs:    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
collections/hash/set.rs:    pub fn shrink_to_fit(&mut self) {
collections/hash/set.rs:    pub fn shrink_to(&mut self, min_capacity: usize) {
collections/hash/set.rs:    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {
collections/hash/set.rs:    pub fn symmetric_difference<'a>(
collections/hash/set.rs:    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {
collections/hash/set.rs:    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {
collections/hash/set.rs:    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool
collections/hash/set.rs:    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>
collections/hash/set.rs:    pub fn get_or_insert(&mut self, value: T) -> &T {
collections/hash/set.rs:    pub fn get_or_insert_owned<Q: ?Sized>(&mut self, value: &Q) -> &T
collections/hash/set.rs:    pub fn get_or_insert_with<Q: ?Sized, F>(&mut self, value: &Q, f: F) -> &T
collections/hash/set.rs:    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {
collections/hash/set.rs:    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {
collections/hash/set.rs:    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {
collections/hash/set.rs:    pub fn insert(&mut self, value: T) -> bool {
collections/hash/set.rs:    pub fn replace(&mut self, value: T) -> Option<T> {
collections/hash/set.rs:    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool
collections/hash/set.rs:    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>
collections/hash/map.rs:    pub fn new() -> HashMap<K, V, RandomState> {
collections/hash/map.rs:    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {
collections/hash/map.rs:    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashMap<K, V, S> {
collections/hash/map.rs:    pub fn capacity(&self) -> usize {
collections/hash/map.rs:    pub fn keys(&self) -> Keys<'_, K, V> {
collections/hash/map.rs:    pub fn into_keys(self) -> IntoKeys<K, V> {
collections/hash/map.rs:    pub fn values(&self) -> Values<'_, K, V> {
collections/hash/map.rs:    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {
collections/hash/map.rs:    pub fn into_values(self) -> IntoValues<K, V> {
collections/hash/map.rs:    pub fn iter(&self) -> Iter<'_, K, V> {
collections/hash/map.rs:    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {
collections/hash/map.rs:    pub fn len(&self) -> usize {
collections/hash/map.rs:    pub fn is_empty(&self) -> bool {
collections/hash/map.rs:    pub fn drain(&mut self) -> Drain<'_, K, V> {
collections/hash/map.rs:    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>
collections/hash/map.rs:    pub fn retain<F>(&mut self, f: F)
collections/hash/map.rs:    pub fn clear(&mut self) {
collections/hash/map.rs:    pub fn hasher(&self) -> &S {
collections/hash/map.rs:    pub fn reserve(&mut self, additional: usize) {
collections/hash/map.rs:    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
collections/hash/map.rs:    pub fn shrink_to_fit(&mut self) {
collections/hash/map.rs:    pub fn shrink_to(&mut self, min_capacity: usize) {
collections/hash/map.rs:    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {
collections/hash/map.rs:    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
collections/hash/map.rs:    pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>
collections/hash/map.rs:    pub fn get_many_mut<Q: ?Sized, const N: usize>(&mut self, ks: [&Q; N]) -> Option<[&'_ mut V; N]>
collections/hash/map.rs:    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool
collections/hash/map.rs:    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
collections/hash/map.rs:    pub fn insert(&mut self, k: K, v: V) -> Option<V> {
collections/hash/map.rs:    pub fn try_insert(&mut self, key: K, value: V) -> Result<&mut V, OccupiedError<'_, K, V>> {
collections/hash/map.rs:    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
collections/hash/map.rs:    pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)>
collections/hash/map.rs:    pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<'_, K, V, S> {
collections/hash/map.rs:    pub fn raw_entry(&self) -> RawEntryBuilder<'_, K, V, S> {
collections/hash/map.rs:    pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>
collections/hash/map.rs:    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>
collections/hash/map.rs:    pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>
collections/hash/map.rs:    pub fn from_key<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>
collections/hash/map.rs:    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> Option<(&'a K, &'a V)>
collections/hash/map.rs:    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>
collections/hash/map.rs:    pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)
collections/hash/map.rs:    pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)
collections/hash/map.rs:    pub fn and_modify<F>(self, f: F) -> Self
collections/hash/map.rs:    pub fn key(&self) -> &K {
collections/hash/map.rs:    pub fn key_mut(&mut self) -> &mut K {
collections/hash/map.rs:    pub fn into_key(self) -> &'a mut K {
collections/hash/map.rs:    pub fn get(&self) -> &V {
collections/hash/map.rs:    pub fn into_mut(self) -> &'a mut V {
collections/hash/map.rs:    pub fn get_mut(&mut self) -> &mut V {
collections/hash/map.rs:    pub fn get_key_value(&mut self) -> (&K, &V) {
collections/hash/map.rs:    pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {
collections/hash/map.rs:    pub fn into_key_value(self) -> (&'a mut K, &'a mut V) {
collections/hash/map.rs:    pub fn insert(&mut self, value: V) -> V {
collections/hash/map.rs:    pub fn insert_key(&mut self, key: K) -> K {
collections/hash/map.rs:    pub fn remove(self) -> V {
collections/hash/map.rs:    pub fn remove_entry(self) -> (K, V) {
collections/hash/map.rs:    pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)
collections/hash/map.rs:    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V)
collections/hash/map.rs:    pub fn or_insert(self, default: V) -> &'a mut V {
collections/hash/map.rs:    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
collections/hash/map.rs:    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {
collections/hash/map.rs:    pub fn key(&self) -> &K {
collections/hash/map.rs:    pub fn and_modify<F>(self, f: F) -> Self
collections/hash/map.rs:    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {
collections/hash/map.rs:    pub fn or_default(self) -> &'a mut V {
collections/hash/map.rs:    pub fn key(&self) -> &K {
collections/hash/map.rs:    pub fn remove_entry(self) -> (K, V) {
collections/hash/map.rs:    pub fn get(&self) -> &V {
collections/hash/map.rs:    pub fn get_mut(&mut self) -> &mut V {
collections/hash/map.rs:    pub fn into_mut(self) -> &'a mut V {
collections/hash/map.rs:    pub fn insert(&mut self, value: V) -> V {
collections/hash/map.rs:    pub fn remove(self) -> V {
collections/hash/map.rs:    pub fn replace_entry(self, value: V) -> (K, V) {
collections/hash/map.rs:    pub fn replace_key(self) -> K {
collections/hash/map.rs:    pub fn key(&self) -> &K {
collections/hash/map.rs:    pub fn into_key(self) -> K {
collections/hash/map.rs:    pub fn insert(self, value: V) -> &'a mut V {
collections/hash/map.rs:    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {
collections/hash/map.rs:    pub fn new() -> RandomState {

env.rs:pub fn current_dir() -> io::Result<PathBuf> {
env.rs:pub fn set_current_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {
env.rs:pub fn vars() -> Vars {
env.rs:pub fn vars_os() -> VarsOs {
env.rs:pub fn var<K: AsRef<OsStr>>(key: K) -> Result<String, VarError> {
env.rs:pub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> {
env.rs:pub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(key: K, value: V) {
env.rs:pub fn remove_var<K: AsRef<OsStr>>(key: K) {
env.rs:pub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths<'_> {
env.rs:pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
env.rs:pub fn home_dir() -> Option<PathBuf> {
env.rs:pub fn temp_dir() -> PathBuf {
env.rs:pub fn current_exe() -> io::Result<PathBuf> {
env.rs:pub fn args() -> Args {
env.rs:pub fn args_os() -> ArgsOs {

ffi/os_str.rs:    pub fn new() -> OsString {
ffi/os_str.rs:    pub fn as_os_str(&self) -> &OsStr {
ffi/os_str.rs:    pub fn into_string(self) -> Result<String, OsString> {
ffi/os_str.rs:    pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {
ffi/os_str.rs:    pub fn with_capacity(capacity: usize) -> OsString {
ffi/os_str.rs:    pub fn clear(&mut self) {
ffi/os_str.rs:    pub fn capacity(&self) -> usize {
ffi/os_str.rs:    pub fn reserve(&mut self, additional: usize) {
ffi/os_str.rs:    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
ffi/os_str.rs:    pub fn reserve_exact(&mut self, additional: usize) {
ffi/os_str.rs:    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
ffi/os_str.rs:    pub fn shrink_to_fit(&mut self) {
ffi/os_str.rs:    pub fn shrink_to(&mut self, min_capacity: usize) {
ffi/os_str.rs:    pub fn into_boxed_os_str(self) -> Box<OsStr> {
ffi/os_str.rs:    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &OsStr {
ffi/os_str.rs:    pub fn to_str(&self) -> Option<&str> {
ffi/os_str.rs:    pub fn to_string_lossy(&self) -> Cow<'_, str> {
ffi/os_str.rs:    pub fn to_os_string(&self) -> OsString {
ffi/os_str.rs:    pub fn is_empty(&self) -> bool {
ffi/os_str.rs:    pub fn len(&self) -> usize {
ffi/os_str.rs:    pub fn into_os_string(self: Box<OsStr>) -> OsString {
ffi/os_str.rs:    pub fn make_ascii_lowercase(&mut self) {
ffi/os_str.rs:    pub fn make_ascii_uppercase(&mut self) {
ffi/os_str.rs:    pub fn to_ascii_lowercase(&self) -> OsString {
ffi/os_str.rs:    pub fn to_ascii_uppercase(&self) -> OsString {
ffi/os_str.rs:    pub fn is_ascii(&self) -> bool {
ffi/os_str.rs:    pub fn eq_ignore_ascii_case<S: AsRef<OsStr>>(&self, other: S) -> bool {

process/tests.rs:pub fn run_output(mut cmd: Command) -> String {
process/tests.rs:pub fn env_cmd() -> Command {
process/tests.rs:pub fn env_cmd() -> Command {
process/tests.rs:pub fn env_cmd() -> Command {
process.rs:    pub fn new<S: AsRef<OsStr>>(program: S) -> Command {
process.rs:    pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {
process.rs:    pub fn args<I, S>(&mut self, args: I) -> &mut Command
process.rs:    pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command
process.rs:    pub fn envs<I, K, V>(&mut self, vars: I) -> &mut Command
process.rs:    pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command {
process.rs:    pub fn env_clear(&mut self) -> &mut Command {
process.rs:    pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command {
process.rs:    pub fn stdin<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command {
process.rs:    pub fn stdout<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command {
process.rs:    pub fn stderr<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command {
process.rs:    pub fn spawn(&mut self) -> io::Result<Child> {
process.rs:    pub fn output(&mut self) -> io::Result<Output> {
process.rs:    pub fn status(&mut self) -> io::Result<ExitStatus> {
process.rs:    pub fn get_program(&self) -> &OsStr {
process.rs:    pub fn get_args(&self) -> CommandArgs<'_> {
process.rs:    pub fn get_envs(&self) -> CommandEnvs<'_> {
process.rs:    pub fn get_current_dir(&self) -> Option<&Path> {
process.rs:    pub fn piped() -> Stdio {
process.rs:    pub fn inherit() -> Stdio {
process.rs:    pub fn null() -> Stdio {
process.rs:    pub fn makes_pipe(&self) -> bool {
process.rs:    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {
process.rs:    pub fn success(&self) -> bool {
process.rs:    pub fn code(&self) -> Option<i32> {
process.rs:    pub fn code(&self) -> Option<i32> {
process.rs:    pub fn code_nonzero(&self) -> Option<NonZeroI32> {
process.rs:    pub fn into_status(&self) -> ExitStatus {
process.rs:    pub fn exit_process(self) -> ! {
process.rs:    pub fn to_i32(self) -> i32 {
process.rs:    pub fn kill(&mut self) -> io::Result<()> {
process.rs:    pub fn id(&self) -> u32 {
process.rs:    pub fn wait(&mut self) -> io::Result<ExitStatus> {
process.rs:    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
process.rs:    pub fn wait_with_output(mut self) -> io::Result<Output> {
process.rs:pub fn exit(code: i32) -> ! {
process.rs:pub fn abort() -> ! {
process.rs:pub fn id() -> u32 {
alloc.rs:pub fn set_alloc_error_hook(hook: fn(Layout)) {
alloc.rs:pub fn take_alloc_error_hook() -> fn(Layout) {
alloc.rs:pub fn rust_oom(layout: Layout) -> ! {
time.rs:    pub fn now() -> Instant {
time.rs:    pub fn duration_since(&self, earlier: Instant) -> Duration {
time.rs:    pub fn checked_duration_since(&self, earlier: Instant) -> Option<Duration> {
time.rs:    pub fn saturating_duration_since(&self, earlier: Instant) -> Duration {
time.rs:    pub fn elapsed(&self) -> Duration {
time.rs:    pub fn checked_add(&self, duration: Duration) -> Option<Instant> {
time.rs:    pub fn checked_sub(&self, duration: Duration) -> Option<Instant> {
time.rs:    pub fn now() -> SystemTime {
time.rs:    pub fn duration_since(&self, earlier: SystemTime) -> Result<Duration, SystemTimeError> {
time.rs:    pub fn elapsed(&self) -> Result<Duration, SystemTimeError> {
time.rs:    pub fn checked_add(&self, duration: Duration) -> Option<SystemTime> {
time.rs:    pub fn checked_sub(&self, duration: Duration) -> Option<SystemTime> {
time.rs:    pub fn duration(&self) -> Duration {
backtrace.rs:    pub fn capture() -> Backtrace {
backtrace.rs:    pub fn force_capture() -> Backtrace {
backtrace.rs:    pub fn status(&self) -> BacktraceStatus {
backtrace.rs:    pub fn frames(&'a self) -> &'a [BacktraceFrame] {
fs.rs:pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {
fs.rs:pub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String> {
fs.rs:pub fn write<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> io::Result<()> {
fs.rs:    pub fn open<P: AsRef<Path>>(path: P) -> io::Result<File> {
fs.rs:    pub fn create<P: AsRef<Path>>(path: P) -> io::Result<File> {
fs.rs:    pub fn create_new<P: AsRef<Path>>(path: P) -> io::Result<File> {
fs.rs:    pub fn options() -> OpenOptions {
fs.rs:    pub fn sync_all(&self) -> io::Result<()> {
fs.rs:    pub fn sync_data(&self) -> io::Result<()> {
fs.rs:    pub fn set_len(&self, size: u64) -> io::Result<()> {
fs.rs:    pub fn metadata(&self) -> io::Result<Metadata> {
fs.rs:    pub fn try_clone(&self) -> io::Result<File> {
fs.rs:    pub fn set_permissions(&self, perm: Permissions) -> io::Result<()> {
fs.rs:    pub fn set_times(&self, times: FileTimes) -> io::Result<()> {
fs.rs:    pub fn set_modified(&self, time: SystemTime) -> io::Result<()> {
fs.rs:    pub fn new() -> Self {
fs.rs:    pub fn read(&mut self, read: bool) -> &mut Self {
fs.rs:    pub fn write(&mut self, write: bool) -> &mut Self {
fs.rs:    pub fn append(&mut self, append: bool) -> &mut Self {
fs.rs:    pub fn truncate(&mut self, truncate: bool) -> &mut Self {
fs.rs:    pub fn create(&mut self, create: bool) -> &mut Self {
fs.rs:    pub fn create_new(&mut self, create_new: bool) -> &mut Self {
fs.rs:    pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> {
fs.rs:    pub fn file_type(&self) -> FileType {
fs.rs:    pub fn is_dir(&self) -> bool {
fs.rs:    pub fn is_file(&self) -> bool {
fs.rs:    pub fn is_symlink(&self) -> bool {
fs.rs:    pub fn len(&self) -> u64 {
fs.rs:    pub fn permissions(&self) -> Permissions {
fs.rs:    pub fn modified(&self) -> io::Result<SystemTime> {
fs.rs:    pub fn accessed(&self) -> io::Result<SystemTime> {
fs.rs:    pub fn created(&self) -> io::Result<SystemTime> {
fs.rs:    pub fn new() -> Self {
fs.rs:    pub fn set_accessed(mut self, t: SystemTime) -> Self {
fs.rs:    pub fn set_modified(mut self, t: SystemTime) -> Self {
fs.rs:    pub fn readonly(&self) -> bool {
fs.rs:    pub fn set_readonly(&mut self, readonly: bool) {
fs.rs:    pub fn is_dir(&self) -> bool {
fs.rs:    pub fn is_file(&self) -> bool {
fs.rs:    pub fn is_symlink(&self) -> bool {
fs.rs:    pub fn path(&self) -> PathBuf {
fs.rs:    pub fn metadata(&self) -> io::Result<Metadata> {
fs.rs:    pub fn file_type(&self) -> io::Result<FileType> {
fs.rs:    pub fn file_name(&self) -> OsString {
fs.rs:pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {
fs.rs:pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {
fs.rs:pub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {
fs.rs:pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()> {
fs.rs:pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {
fs.rs:pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {
fs.rs:pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {
fs.rs:pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {
fs.rs:pub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {
fs.rs:pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {
fs.rs:pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {
fs.rs:pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {
fs.rs:pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {
fs.rs:pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {
fs.rs:pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions) -> io::Result<()> {
fs.rs:    pub fn new() -> DirBuilder {
fs.rs:    pub fn recursive(&mut self, recursive: bool) -> &mut Self {
fs.rs:    pub fn create<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
fs.rs:pub fn try_exists<P: AsRef<Path>>(path: P) -> io::Result<bool> {
path/tests.rs:pub fn test_decompositions_unix() {
path/tests.rs:pub fn test_decompositions_windows() {
path/tests.rs:pub fn test_stem_ext() {
path/tests.rs:pub fn test_prefix_ext() {
path/tests.rs:pub fn test_push() {
path/tests.rs:pub fn test_pop() {
path/tests.rs:pub fn test_set_file_name() {
path/tests.rs:pub fn test_set_extension() {
path/tests.rs:pub fn test_compare() {
f64.rs:    pub fn floor(self) -> f64 {
f64.rs:    pub fn ceil(self) -> f64 {
f64.rs:    pub fn round(self) -> f64 {
f64.rs:    pub fn round_ties_even(self) -> f64 {
f64.rs:    pub fn trunc(self) -> f64 {
f64.rs:    pub fn fract(self) -> f64 {
f64.rs:    pub fn abs(self) -> f64 {
f64.rs:    pub fn signum(self) -> f64 {
f64.rs:    pub fn copysign(self, sign: f64) -> f64 {
f64.rs:    pub fn mul_add(self, a: f64, b: f64) -> f64 {
f64.rs:    pub fn div_euclid(self, rhs: f64) -> f64 {
f64.rs:    pub fn rem_euclid(self, rhs: f64) -> f64 {
f64.rs:    pub fn powi(self, n: i32) -> f64 {
f64.rs:    pub fn powf(self, n: f64) -> f64 {
f64.rs:    pub fn sqrt(self) -> f64 {
f64.rs:    pub fn exp(self) -> f64 {
f64.rs:    pub fn exp2(self) -> f64 {
f64.rs:    pub fn ln(self) -> f64 {
f64.rs:    pub fn log(self, base: f64) -> f64 {
f64.rs:    pub fn log2(self) -> f64 {
f64.rs:    pub fn log10(self) -> f64 {
f64.rs:    pub fn abs_sub(self, other: f64) -> f64 {
f64.rs:    pub fn cbrt(self) -> f64 {
f64.rs:    pub fn hypot(self, other: f64) -> f64 {
f64.rs:    pub fn sin(self) -> f64 {
f64.rs:    pub fn cos(self) -> f64 {
f64.rs:    pub fn tan(self) -> f64 {
f64.rs:    pub fn asin(self) -> f64 {
f64.rs:    pub fn acos(self) -> f64 {
f64.rs:    pub fn atan(self) -> f64 {
f64.rs:    pub fn atan2(self, other: f64) -> f64 {
f64.rs:    pub fn sin_cos(self) -> (f64, f64) {
f64.rs:    pub fn exp_m1(self) -> f64 {
f64.rs:    pub fn ln_1p(self) -> f64 {
f64.rs:    pub fn sinh(self) -> f64 {
f64.rs:    pub fn cosh(self) -> f64 {
f64.rs:    pub fn tanh(self) -> f64 {
f64.rs:    pub fn asinh(self) -> f64 {
f64.rs:    pub fn acosh(self) -> f64 {
f64.rs:    pub fn atanh(self) -> f64 {
num.rs:pub fn test_num<T>(ten: T, two: T)
personality/dwarf/mod.rs:    pub fn new(ptr: *const u8) -> DwarfReader {
